<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EGSEE</title>
  
  <subtitle>SmallHouse</subtitle>
  <link href="/public-blog/atom.xml" rel="self"/>
  
  <link href="https://egsee.github.io/"/>
  <updated>2022-03-15T01:50:36.009Z</updated>
  <id>https://egsee.github.io/</id>
  
  <author>
    <name>egsee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker Entrypoint</title>
    <link href="https://egsee.github.io/posts/7fe8ab1e/"/>
    <id>https://egsee.github.io/posts/7fe8ab1e/</id>
    <published>2022-03-15T01:43:19.820Z</published>
    <updated>2022-03-15T01:50:36.009Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis-entrypoint-example"><a href="#redis-entrypoint-example" class="headerlink" title="redis entrypoint example"></a>redis entrypoint example</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'redis-server'</span> -a <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></span><br><span class="line">find . \! -user redis -<span class="built_in">exec</span> chown redis <span class="string">'&#123;&#125;'</span> +</span><br><span class="line"><span class="built_in">exec</span> gosu redis <span class="string">"<span class="variable">$0</span>"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><p>该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure><h3 id="postgres"><a href="#postgres" class="headerlink" title="postgres"></a>postgres</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'postgres'</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R postgres <span class="string">"<span class="variable">$PGDATA</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$(ls -A "$PGDATA")</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exec</span> gosu postgres <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p></blockquote><p>该辅助脚本被拷贝到容器，并在容器启动时通过 ENTRYPOINT 执行：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker-entrypoint.sh /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/docker-entrypoint.sh"</span>]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis-entrypoint-example&quot;&gt;&lt;a href=&quot;#redis-entrypoint-example&quot; class=&quot;headerlink&quot; title=&quot;redis entrypoint example&quot;&gt;&lt;/a&gt;redis entrypoi
      
    
    </summary>
    
    
      <category term="片段" scheme="https://egsee.github.io/categories/%E7%89%87%E6%AE%B5/"/>
    
    
      <category term="dockerfile" scheme="https://egsee.github.io/tags/dockerfile/"/>
    
      <category term="docker" scheme="https://egsee.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Js EventLoop</title>
    <link href="https://egsee.github.io/posts/b02d5628/"/>
    <id>https://egsee.github.io/posts/b02d5628/</id>
    <published>2022-01-21T05:01:01.000Z</published>
    <updated>2022-03-15T01:47:24.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-Event-Loop"><a href="#The-Event-Loop" class="headerlink" title="The Event Loop"></a>The Event Loop</h1><p>Javascript has a runtime model based on <strong>Event Loop</strong>, which is responsible for excuting the code, collecting and processing events, and excuting queued sub-tasks. The model is quite different from models in other languages like C and Java.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-Event-Loop&quot;&gt;&lt;a href=&quot;#The-Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;The Event Loop&quot;&gt;&lt;/a&gt;The Event Loop&lt;/h1&gt;&lt;p&gt;Javascript has a runti
      
    
    </summary>
    
    
      <category term="前端基础" scheme="https://egsee.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="https://egsee.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Go数组和切片</title>
    <link href="https://egsee.github.io/posts/94f857ff/"/>
    <id>https://egsee.github.io/posts/94f857ff/</id>
    <published>2021-12-01T11:13:16.000Z</published>
    <updated>2022-03-01T09:34:43.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Go 数组是具有相同 唯一类型 的一组已编号且长度固定的数据项序列</p><h3 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>数组声明后值分配为零，在内存中是连续固定不可变的区域。<br>数组是值类型，意味着传递数组会重新复制一份传递，这和 C 或 Java 有所不同<br><img src="/public-blog/img/posts/go-arr.png" alt=""></p><a id="more"></a><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr1); i++ &#123;</span><br><span class="line">       arr1[i] = i * <span class="number">2</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr1); i++ &#123;</span><br><span class="line">       fmt.Printf(<span class="string">"Array at index %d is %d\n"</span>, i, arr1[i])</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>切片（slice）是对数组一个连续片段的引用，其底层是数组，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型），可以将其理解为一个可变数组。</p><h3 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度3 容量5的切片</span></span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s3 := s1[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义数组</span></span><br><span class="line">arr := [<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s := a[:] <span class="comment">//转换为slice</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// s = &#123;1,2,3,4,5&#125;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br></pre></td></tr></table></figure><h3 id="内存示意"><a href="#内存示意" class="headerlink" title="内存示意"></a>内存示意</h3><p><img src="/public-blog/img/posts/go-arr.png" alt=""></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr1 [<span class="number">6</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> slice1 []<span class="keyword">int</span> = arr1[<span class="number">2</span>:<span class="number">5</span>] <span class="comment">// item at index 5 not included!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load the array with integers: 0,1,2,3,4,5</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr1); i++ &#123;</span><br><span class="line">        arr1[i] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the slice</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice1); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Slice at %d is %d\n"</span>, i, slice1[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"The length of arr1 is %d\n"</span>, <span class="built_in">len</span>(arr1))</span><br><span class="line">    fmt.Printf(<span class="string">"The length of slice1 is %d\n"</span>, <span class="built_in">len</span>(slice1))</span><br><span class="line">    fmt.Printf(<span class="string">"The capacity of slice1 is %d\n"</span>, <span class="built_in">cap</span>(slice1))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// grow the slice</span></span><br><span class="line">    slice1 = slice1[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice1); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Slice at %d is %d\n"</span>, i, slice1[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"The length of slice1 is %d\n"</span>, <span class="built_in">len</span>(slice1))</span><br><span class="line">    fmt.Printf(<span class="string">"The capacity of slice1 is %d\n"</span>, <span class="built_in">cap</span>(slice1))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// grow the slice beyond capacity</span></span><br><span class="line">    <span class="comment">//slice1 = slice1[0:7 ] // panic: runtime error: slice bound out of range</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="slicing-细节"><a href="#slicing-细节" class="headerlink" title="slicing 细节"></a>slicing 细节</h3><p>s := make([]int, 5)，s 底层即为上图的数据结构。ptr 是一个指针，指向底层对应的数组。len 是切片的长度 5，cap 是底层数组的容量 5。</p><p>当我们执行下面语句时 ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s2 := s[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>做 slicing 的时候，go 会新建一个 slice 值 s2，而底层的数据是不动的。s2 如上图深蓝色，通过更改指针、长度和容量来进行 slicing。这也就是为什么 slicing 的性能非常高的原因。</p><p>一个 slice 不能越过 cap 进行操作，这个我们从底层很容易理解，因为就相当于越过底层数组的上界进行非法访问了。</p><h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h3><p>使用内部函数 append 来往切片 slice 后动态追加元素，当 cap 不够时，如果 reslice 后可以放下，那么它会 reslice。例如上面的 s2，底层的数组足以再追加 2 个元素。如果不行，那么它会 new 一个新的底层数组，大小为之前 cap 的两倍，并将之前的元素复制进去:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// 输出7 10</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))<span class="comment">//输出11 20</span></span><br><span class="line">如果要追加一个slice到另一个slice的话，这样：</span><br><span class="line"></span><br><span class="line">s5 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">s6 := []<span class="keyword">int</span>&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>&#125;</span><br><span class="line">s := <span class="built_in">append</span>(s5, s6...)</span><br><span class="line">fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))<span class="comment">//输出[0 0 0 0 0 11 22 33 44 55 66] 11 12</span></span><br></pre></td></tr></table></figure><h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><p>在这样的场景下注意：如果我们只用到一个 slice 的一小部分，那么底层的整个数组也将继续保存在内存当中。当这个底层数组很大，或者这样的场景很多时，可能会造成内存急剧增加，造成崩溃。</p><p>所以在这样的场景下，我们可以将需要的分片复制到一个新的 slice 中去，减少内存的占用。例如一个很大的切片 data 里，我们需要的数据是 data[m:n]，那么我们创建一个新的 slice 变量 r，将数据复制到 r 中返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mydata := data[m:n]</span><br><span class="line">r := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(mydata))</span><br><span class="line"><span class="built_in">copy</span>(r, mydata)</span><br><span class="line"><span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><h2 id="举例区别"><a href="#举例区别" class="headerlink" title="举例区别"></a>举例区别</h2><p>切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">numbers := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, e := <span class="keyword">range</span> numbers &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(numbers)<span class="number">-1</span> &#123;</span><br><span class="line"></span><br><span class="line">        numbers[<span class="number">0</span>] += e</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        numbers[i+<span class="number">1</span>] += e</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(numbers) <span class="comment">// [22 3 6 10 15 21]</span></span><br></pre></td></tr></table></figure><p>数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">numbers := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, e := <span class="keyword">range</span> numbers &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(numbers)<span class="number">-1</span> &#123;</span><br><span class="line"></span><br><span class="line">        numbers[<span class="number">0</span>] += e</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        numbers[i+<span class="number">1</span>] += e</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(numbers) <span class="comment">// [7 3 5 7 9 11]</span></span><br></pre></td></tr></table></figure><p>遍历时数组类型是值类型，而切片是指针类型，每次传递的是指针，所以每次累加，都是改变后的值来累加。</p><h2 id="使用-Benchmark-展示-slice-内存使用"><a href="#使用-Benchmark-展示-slice-内存使用" class="headerlink" title="使用 Benchmark 展示 slice 内存使用"></a>使用 Benchmark 展示 slice 内存使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateWithCap</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">nums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">nums = <span class="built_in">append</span>(nums, rand.Int())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">nums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">nums = <span class="built_in">append</span>(nums, rand.Int())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGenerateWithCap</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">generateWithCap(<span class="number">1000000</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGenerate</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">generate(<span class="number">1000000</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test -bench=<span class="string">'Generate'</span> .</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: example</span><br><span class="line">BenchmarkGenerateWithCap<span class="number">-8</span>            <span class="number">44</span>          <span class="number">24294582</span> ns/op</span><br><span class="line">BenchmarkGenerate<span class="number">-8</span>                   <span class="number">34</span>          <span class="number">30342763</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      example <span class="number">2.171</span>s</span><br></pre></td></tr></table></figure><p>可以看到生成 100w 个数字的随机序列，GenerateWithCap 的耗时比 Generate 少 20%。<br>使用 -benchmem 参数看到内存分配的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: example</span><br><span class="line">BenchmarkGenerateWithCap-8  43  24335658 ns/op  8003641 B/op    1 allocs/op</span><br><span class="line">BenchmarkGenerate-8         33  30403687 ns/op  45188395 B/op  40 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      example 2.121s</span><br></pre></td></tr></table></figure><p>Generate 分配的内存是 GenerateWithCap 的 6 倍，设置了切片容量，内存只分配一次，而不设置切片容量，内存分配了 40 次。</p><p>参考：<br><a href="https://geektutu.com/post/hpg-benchmark.html">Go语言高性能编程</a><br><a href="https://zhuanlan.zhihu.com/p/78747815">数组和切片</a><br><a href="https://cloud.tencent.com/developer/article/1354294">搞懂golang中的数组和切片slice</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;Go 数组是具有相同 唯一类型 的一组已编号且长度固定的数据项序列&lt;/p&gt;
&lt;h3 id=&quot;声明方式&quot;&gt;&lt;a href=&quot;#声明方式&quot; class=&quot;headerlink&quot; title=&quot;声明方式&quot;&gt;&lt;/a&gt;声明方式&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;arr := [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//or&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr := [...]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;数组声明后值分配为零，在内存中是连续固定不可变的区域。&lt;br&gt;数组是值类型，意味着传递数组会重新复制一份传递，这和 C 或 Java 有所不同&lt;br&gt;&lt;img src=&quot;/public-blog/img/posts/go-arr.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="go" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
      <category term="go" scheme="https://egsee.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Java &lt;T&gt; T 和 T的区别</title>
    <link href="https://egsee.github.io/posts/2cc6c3c4/"/>
    <id>https://egsee.github.io/posts/2cc6c3c4/</id>
    <published>2021-09-30T05:01:16.000Z</published>
    <updated>2021-11-19T07:41:36.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>最近在看Java的过程中对形如<code>public &lt;T&gt; T get(...)</code>的写法感到困惑，在网上很难找到合理解释。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObjectData</span><span class="params">(ByteBuffer buffer, Class&lt;T&gt; type)</span></span></span><br></pre></td></tr></table></figure><p>在上面这个方法中<br><code>&lt;T&gt;</code>代表声明了一个 通用的泛型参数<code>T</code><br><code>T</code>作为一个实际的占位符，代表返回值为<code>T</code>类型，实际返回类型只会在使用<code>非泛型</code>类型参数调用时才会确定。<br>如果这里不定义<code>&lt;T&gt;</code>,那么编译器将认为类型<code>T</code>不存在。<br>举例来说：<br>如果你传递<code>Class&lt;String&gt;</code>类型则返回的就是<code>String类型</code>、传递<code>Class&lt;Double&gt;</code>则返回<code>Dubbo</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String obj1 = clazz.readObjectData(buffer, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">MyClass obj2 = clazz.readObjectData(buffer, MyClass<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>大多数初学者有这样的疑惑，估计是还有以下这种类似让人迷惑的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> T <span class="title">myMethod</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  a;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写因为在类上已经定义了<code>&lt;T&gt;</code>泛型参数，所以无需重复定义，如果你这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">myMethod</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  a;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么<code>myMethod</code>将返回的泛型类型可能不与<code>MyClass</code>相同，实际上像以下这样定义可能更加清晰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T1</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> &lt;T2&gt; <span class="function">T2 <span class="title">myMethod</span><span class="params">(T2 a)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  a;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/15888551/how-to-interpret-public-t-t-readobjectdata-classt-type-in-java">How to interpret “public &lt;T&gt; T” in Java</a><br><a href="https://docs.oracle.com/javase/tutorial/extra/generics/literals.html">Class Literals as Runtime-Type Tokens</a><br><a href="https://stackoverflow.com/questions/6503942/how-to-interpret-java-generics-like-t-t-t-v-queryt-classt">How to interpret Java generics like &lt;T&gt; T , &lt;T,V&gt; Query&lt;T&gt; , Class&lt;T&gt;?</a><br><a href="https://stackoverflow.com/questions/36363078/what-does-t-t-get-mean-and-is-it-useful">What does “&lt;T&gt; T get()” mean?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;最近在看Java的过程中对形如&lt;code&gt;public &amp;lt;T&amp;gt; T get(...)&lt;/code&gt;的写法感到困惑，在网上很难找到合理解释。&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;readObjectData&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ByteBuffer buffer, Class&amp;lt;T&amp;gt; type)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在上面这个方法中&lt;br&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;代表声明了一个 通用的泛型参数&lt;code&gt;T&lt;/code&gt;&lt;br&gt;&lt;code&gt;T&lt;/code&gt;作为一个实际的占位符，代表返回值为&lt;code&gt;T&lt;/code&gt;类型，实际返回类型只会在使用&lt;code&gt;非泛型&lt;/code&gt;类型参数调用时才会确定。&lt;br&gt;如果这里不定义&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;,那么编译器将认为类型&lt;code&gt;T&lt;/code&gt;不存在。&lt;br&gt;举例来说：&lt;br&gt;如果你传递&lt;code&gt;Class&amp;lt;String&amp;gt;&lt;/code&gt;类型则返回的就是&lt;code&gt;String类型&lt;/code&gt;、传递&lt;code&gt;Class&amp;lt;Double&amp;gt;&lt;/code&gt;则返回&lt;code&gt;Dubbo&lt;/code&gt;类型：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String obj1 = clazz.readObjectData(buffer, String&lt;span class=&quot;class&quot;&gt;.&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MyClass obj2 = clazz.readObjectData(buffer, MyClass&lt;span class=&quot;class&quot;&gt;.&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="java" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/java/"/>
    
    
      <category term="java" scheme="https://egsee.github.io/tags/java/"/>
    
      <category term="泛型" scheme="https://egsee.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="https://egsee.github.io/posts/a1501c1d/"/>
    <id>https://egsee.github.io/posts/a1501c1d/</id>
    <published>2021-09-16T11:13:16.000Z</published>
    <updated>2021-11-19T07:42:11.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>Java的注解从JDK5引入，有的注解仅仅帮助IDE给出相应提示，有的注解在<code>runtime</code>时会被解析成字节码，通过反射获取注解内容，有的注解专门约束其它注解类，这样的<code>Anotation</code>被称为<code>元注解</code>，本文结合自己的理解将逐一对其进行介绍。</p><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><p>Java的内置注解一共有7个，3个定义在<code>java.lang</code>中，另外4个定义在<code>java.lang.annotation</code>中，为了方便，我这里把<code>java.lang</code>中定义的注解称为<code>内置注解</code>，<code>java.lang.annotation</code>定义的注解成为<code>元注解</code>。</p><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p>检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</p><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>标记过时方法，如果使用使用，编译器会给出相应警告。</p><h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><p>指示编译器去忽略注解中声明的警告。比如：<code>@SuppressWarnings(&quot;deprecation&quot;)</code>,<code>@SuppressWarnings({&quot;deprecation&quot;, &quot;unused&quot;, &quot;unchecked&quot;})</code></p><h2 id="元注解（作用于其它注解上的注解）"><a href="#元注解（作用于其它注解上的注解）" class="headerlink" title="元注解（作用于其它注解上的注解）"></a>元注解（作用于其它注解上的注解）</h2><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p> 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。<br> 它的值有以下几个构成：</p><ul><li><strong>RetentionPolicy.SOURCE</strong>: Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了。</li><li><strong>RetentionPolicy.CLASS</strong>: 编译器将Annotation存储于类对应的.class文件中。默认行为。</li><li><strong>RetentionPolicy.RUNTIME</strong>: 编译器将Annotation存储于class文件中，并且可由JVM读入。</li></ul><a id="more"></a><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>假设有一个我们自定义了一个名叫<code>TestAnn</code>的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// @Retention(RetentionPolicy.RUNTIME) #可通过反射获取注解内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @Retention(RetentionPolicy.SOURCE) #编译器将忽视TestAnn注释</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnn &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p>对一个自定义注解约束其使用范围，有如下值可选：</p><ul><li>ElementType.TYPE - 用在类，接口，枚举，注解的声明</li><li>ElementType.FIELD - 用在字段的和枚举常量</li><li>ElementType.METHOD - 用在方法的声明</li><li>ElementType.PARAMETER - 用在参数的声明</li><li>ElementType.CONSTRUCTOR - 在构造函数的声明</li><li>ElementType.LOCAL_VARIABLE - 用在局部变量的声明</li><li>ElementType.ANNOTATION_TYPE - 用在注释的声明</li><li>ElementType.PACKAGE - 用在包的声明<h3 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 约束注释只能用在字段和方法上</span></span><br><span class="line"><span class="meta">@Target</span>(value = &#123; ElementType.FIELD, ElementType.METHOD &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnn &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h2><p>标记这些注解是否包含在用户文档中。</p><h2 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h2><p>标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</p><h2 id="SafeVarargs-Java7支持"><a href="#SafeVarargs-Java7支持" class="headerlink" title="@SafeVarargs (Java7支持)"></a>@SafeVarargs (Java7支持)</h2><p>忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</p><h2 id="FunctionalInterface（Java8支持）"><a href="#FunctionalInterface（Java8支持）" class="headerlink" title="@FunctionalInterface（Java8支持）"></a>@FunctionalInterface（Java8支持）</h2><p>标识一个匿名函数或函数式接口。</p><h2 id="Repeatable（Java8支持）"><a href="#Repeatable（Java8支持）" class="headerlink" title="@Repeatable（Java8支持）"></a>@Repeatable（Java8支持）</h2><p>标识某注解可以在同一个声明上使用多次。</p><h2 id="注解的架构"><a href="#注解的架构" class="headerlink" title="注解的架构"></a>注解的架构</h2><p><img src="/public-blog/img/posts/annotation-schema.jpg" alt=""><br>Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等。<br><img src="/public-blog/img/posts/annotation-schema1.jpg" alt=""></p><h2 id="注解代码的组成"><a href="#注解代码的组成" class="headerlink" title="注解代码的组成"></a>注解代码的组成</h2><p>Annotation.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Annotation.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ElementType.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ElementType.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    TYPE,               <span class="comment">/* 类、接口（包括注释类型）或枚举声明  */</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">/* 字段声明（包括枚举常量）  */</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">/* 方法声明  */</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">/* 参数声明  */</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">/* 构造方法声明  */</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">/* 局部变量声明  */</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">/* 注释类型声明  */</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">/* 包声明  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RetentionPolicy.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RetentionPolicy.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    SOURCE,            <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>UlRenderBorder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UlRenderBorder</span></span><br><span class="line"><span class="keyword">package</span> com.example.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value = &#123; ElementType.TYPE &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UlBorderRender &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">border</span><span class="params">()</span> <span class="keyword">default</span> "border: 1px solid #000"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.annotation.UlBorderRender;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; draw = Draw<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasUL = draw.isAnnotationPresent(UlBorderRender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// Method[] methods = draw.getMethods();</span></span><br><span class="line">    <span class="keyword">if</span>(hasUL)&#123;</span><br><span class="line">      StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      UlBorderRender ulAnn = draw.getAnnotation(UlBorderRender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      str.append(<span class="string">"&lt;ul&gt;"</span> + ulAnn.border() + <span class="string">"&lt;/ul&gt;"</span>);</span><br><span class="line">      System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;Java的注解从JDK5引入，有的注解仅仅帮助IDE给出相应提示，有的注解在&lt;code&gt;runtime&lt;/code&gt;时会被解析成字节码，通过反射获取注解内容，有的注解专门约束其它注解类，这样的&lt;code&gt;Anotation&lt;/code&gt;被称为&lt;code&gt;元注解&lt;/code&gt;，本文结合自己的理解将逐一对其进行介绍。&lt;/p&gt;
&lt;h2 id=&quot;内置注解&quot;&gt;&lt;a href=&quot;#内置注解&quot; class=&quot;headerlink&quot; title=&quot;内置注解&quot;&gt;&lt;/a&gt;内置注解&lt;/h2&gt;&lt;p&gt;Java的内置注解一共有7个，3个定义在&lt;code&gt;java.lang&lt;/code&gt;中，另外4个定义在&lt;code&gt;java.lang.annotation&lt;/code&gt;中，为了方便，我这里把&lt;code&gt;java.lang&lt;/code&gt;中定义的注解称为&lt;code&gt;内置注解&lt;/code&gt;，&lt;code&gt;java.lang.annotation&lt;/code&gt;定义的注解成为&lt;code&gt;元注解&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;Override&quot;&gt;&lt;a href=&quot;#Override&quot; class=&quot;headerlink&quot; title=&quot;@Override&quot;&gt;&lt;/a&gt;@Override&lt;/h3&gt;&lt;p&gt;检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。&lt;/p&gt;
&lt;h3 id=&quot;Deprecated&quot;&gt;&lt;a href=&quot;#Deprecated&quot; class=&quot;headerlink&quot; title=&quot;@Deprecated&quot;&gt;&lt;/a&gt;@Deprecated&lt;/h3&gt;&lt;p&gt;标记过时方法，如果使用使用，编译器会给出相应警告。&lt;/p&gt;
&lt;h3 id=&quot;SuppressWarnings&quot;&gt;&lt;a href=&quot;#SuppressWarnings&quot; class=&quot;headerlink&quot; title=&quot;@SuppressWarnings&quot;&gt;&lt;/a&gt;@SuppressWarnings&lt;/h3&gt;&lt;p&gt;指示编译器去忽略注解中声明的警告。比如：&lt;code&gt;@SuppressWarnings(&amp;quot;deprecation&amp;quot;)&lt;/code&gt;,&lt;code&gt;@SuppressWarnings({&amp;quot;deprecation&amp;quot;, &amp;quot;unused&amp;quot;, &amp;quot;unchecked&amp;quot;})&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;元注解（作用于其它注解上的注解）&quot;&gt;&lt;a href=&quot;#元注解（作用于其它注解上的注解）&quot; class=&quot;headerlink&quot; title=&quot;元注解（作用于其它注解上的注解）&quot;&gt;&lt;/a&gt;元注解（作用于其它注解上的注解）&lt;/h2&gt;&lt;h3 id=&quot;Retention&quot;&gt;&lt;a href=&quot;#Retention&quot; class=&quot;headerlink&quot; title=&quot;@Retention&quot;&gt;&lt;/a&gt;@Retention&lt;/h3&gt;&lt;p&gt; 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。&lt;br&gt; 它的值有以下几个构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RetentionPolicy.SOURCE&lt;/strong&gt;: Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RetentionPolicy.CLASS&lt;/strong&gt;: 编译器将Annotation存储于类对应的.class文件中。默认行为。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RetentionPolicy.RUNTIME&lt;/strong&gt;: 编译器将Annotation存储于class文件中，并且可由JVM读入。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="java" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/java/"/>
    
    
      <category term="java注解,java annotation" scheme="https://egsee.github.io/tags/java%E6%B3%A8%E8%A7%A3-java-annotation/"/>
    
  </entry>
  
  <entry>
    <title>NPM Workspaces简介</title>
    <link href="https://egsee.github.io/posts/923ed035/"/>
    <id>https://egsee.github.io/posts/923ed035/</id>
    <published>2021-09-01T11:13:16.000Z</published>
    <updated>2021-11-13T08:06:52.787Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>npm在2020年10月发布的版本开始支持一个新功能：Workspaces</p></blockquote><h3 id="Workspaces是什么？"><a href="#Workspaces是什么？" class="headerlink" title="Workspaces是什么？"></a>Workspaces是什么？</h3><p><code>Workspaces</code>即工作区，可以帮我们管理包含多个<code>包（package）</code>的项目，这些项目（称为monorepo）可能包含多个<code>package.json</code>，而Workspaces可以方便的对这类项目进行管理。</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>一个简单的多包依赖项目的例子如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── index.js</span><br><span class="line">├── package.json</span><br><span class="line">└── packages</span><br><span class="line">    ├── packageA</span><br><span class="line">    │   ├── index.js</span><br><span class="line">    │   └── package.json # Dependencies: `vuepress`,`packageB`</span><br><span class="line">    └── packageB</span><br><span class="line">        ├── index.js</span><br><span class="line">        └── package.json # Dependencies: `vuepress`, `packageA`</span><br></pre></td></tr></table></figure><a id="more"></a><p>当我们在根目录运行<code>npm install</code> 或 <code>yarn install</code>的时候，npm会在根文件的<code>node_modules</code>下创建彼此的符号链接，以便package能够引入，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules # 根文件 node_modules</span><br><span class="line">│   ├── vuepress # 依赖的vuepress</span><br><span class="line">│   ├── packageA # 符号链接包A</span><br><span class="line">│   └── packageB # 符号链接包B</span><br></pre></td></tr></table></figure><h3 id="配置和使用"><a href="#配置和使用" class="headerlink" title="配置和使用"></a>配置和使用</h3><p>在根项目目录下的<code>packages.json</code>中配置<code>workspaces</code>关键字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"workspaces"</span>: [</span><br><span class="line">    <span class="string">"packages/*"</span>,</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>子包中的<code>package.json</code>添加<code>dependencies</code>对其它包的依赖<br>然后运行npm，则可以在子包中非常方便的使用本地依赖库了。</p><h3 id="其它用法"><a href="#其它用法" class="headerlink" title="其它用法"></a>其它用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Run "test" script on all packages</span><br><span class="line">npm run test --workspaces</span><br><span class="line">npm run test  -ws</span><br><span class="line"></span><br><span class="line"># Runs "test" only on packageA</span><br><span class="line">npm run test --workspace packageA</span><br><span class="line">npm run test -w packageB</span><br><span class="line"></span><br><span class="line"># Install `lodash` on `packageA`</span><br><span class="line">npm install lodash --workspace packageA</span><br><span class="line"></span><br><span class="line"># Install `tap` on `packageB` as a dev dependency</span><br><span class="line">npm install tap --workspace packageB --save-dev</span><br><span class="line"></span><br><span class="line"># Install `packageA` on `packageB`</span><br><span class="line">npm install packageA --workspace packageB</span><br><span class="line"></span><br><span class="line"># Install `eslint` in all packages</span><br><span class="line">npm install eslint --workspaces</span><br></pre></td></tr></table></figure><h3 id="npm-工作区-与-Yarn-工作区"><a href="#npm-工作区-与-Yarn-工作区" class="headerlink" title="npm 工作区 与 Yarn 工作区"></a>npm 工作区 与 Yarn 工作区</h3><p>Yarn中也有命令来管理workspaces,<br>例如： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn workspace &lt;workspace&gt; add &lt;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="使用-Lerna"><a href="#使用-Lerna" class="headerlink" title="使用 Lerna"></a>使用 Lerna</h3><p>使用 npm workspaces 和 yarn workspaces 虽然可以管理一些monorepos<br>但对于一些更大的项目来说，它包含更多的依赖树，这时可能就要使用类似<a href="https://github.com/lerna/lerna">Lerna</a>这样的管理工具了。<br>Lerna 有很多命令来管理大型的monorepo。<br>在<a href="https://github.com/vuepress/vuepress-next">VuePress</a>项目中结合使用了这两个功能，读者可以参考其用法。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://docs.npmjs.com/cli/v7/using-npm/workspaces">NPM Workspaces</a><br><a href="https://ruanmartinelli.com/posts/npm-7-workspaces-1">Getting Started with npm Workspaces</a><br><a href="https://github.com/vuepress/vuepress-next">Vuepress repository</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;npm在2020年10月发布的版本开始支持一个新功能：Workspaces&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Workspaces是什么？&quot;&gt;&lt;a href=&quot;#Workspaces是什么？&quot; class=&quot;headerlink&quot; title=&quot;Workspaces是什么？&quot;&gt;&lt;/a&gt;Workspaces是什么？&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Workspaces&lt;/code&gt;即工作区，可以帮我们管理包含多个&lt;code&gt;包（package）&lt;/code&gt;的项目，这些项目（称为monorepo）可能包含多个&lt;code&gt;package.json&lt;/code&gt;，而Workspaces可以方便的对这类项目进行管理。&lt;/p&gt;
&lt;h3 id=&quot;举例说明&quot;&gt;&lt;a href=&quot;#举例说明&quot; class=&quot;headerlink&quot; title=&quot;举例说明&quot;&gt;&lt;/a&gt;举例说明&lt;/h3&gt;&lt;p&gt;一个简单的多包依赖项目的例子如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;├── index.js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── package.json&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── packages&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ├── packageA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    │   ├── index.js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    │   └── package.json # Dependencies: `vuepress`,`packageB`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    └── packageB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├── index.js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        └── package.json # Dependencies: `vuepress`, `packageA`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="https://egsee.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="npm" scheme="https://egsee.github.io/tags/npm/"/>
    
      <category term="workspaces" scheme="https://egsee.github.io/tags/workspaces/"/>
    
  </entry>
  
  <entry>
    <title>Springboot打开热部署</title>
    <link href="https://egsee.github.io/posts/aa953346/"/>
    <id>https://egsee.github.io/posts/aa953346/</id>
    <published>2021-08-21T11:13:16.000Z</published>
    <updated>2021-11-20T04:10:53.626Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在使用<code>Springboot</code>热启动的时候，参照了网上很多方法，但发现很多不全。</p></blockquote><h2 id="如何使用Springboot热启动"><a href="#如何使用Springboot热启动" class="headerlink" title="如何使用Springboot热启动"></a>如何使用<code>Springboot</code>热启动</h2><ol><li><p><code>pom.xml</code>添加依赖<code>spring-boot-devtools</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  spring-boot hot refresh  --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>spring-boot-maven-plugin</code>添加配置项<code>fork: true</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    set ture to enable hot start of devtools    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>打开<code>Preferences</code>(Mac cmd + ，)找到<code>Build, Exception, Deployme</code>下的<code>compiler</code>,单击<code>Compiler</code>,在右边<code>Build project automatically</code>选项框内打勾。</p><p><img src="/public-blog/img/posts/spring-devtools1.png" alt=""></p><a id="more"></a></li></ol><ol start="4"><li><p>打开auto-make,操作如下：<br>(IDEA 2021.2版本以后)<br><code>cmd + ,</code>（Mac）打开<code>Preferences</code>，找到<code>Advanced Settings</code>,勾选右边的<code>Allow auto-make to start...</code>选项卡。</p><p><img src="/public-blog/img/posts/spring-devtools2.png" alt=""><br>(IDEA 2021.2版本以前)<br><code>option+cmd+shift+/</code>(windows <code>ctrl+alt+shift + /</code> ) 选择 <code>Registry</code> 勾选<code>compiler.automake.allow.when.app.running</code></p></li></ol><p>5.<code>application.properties</code>中添加<code>spring.devtools.restart.enabled=true</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在使用&lt;code&gt;Springboot&lt;/code&gt;热启动的时候，参照了网上很多方法，但发现很多不全。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;如何使用Springboot热启动&quot;&gt;&lt;a href=&quot;#如何使用Springboot热启动&quot; class=&quot;headerlink&quot; title=&quot;如何使用Springboot热启动&quot;&gt;&lt;/a&gt;如何使用&lt;code&gt;Springboot&lt;/code&gt;热启动&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;pom.xml&lt;/code&gt;添加依赖&lt;code&gt;spring-boot-devtools&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--  spring-boot hot refresh  --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-devtools&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;runtime&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;spring-boot-maven-plugin&lt;/code&gt;添加配置项&lt;code&gt;fork: true&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--    set ture to enable hot start of devtools    --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;fork&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;fork&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开&lt;code&gt;Preferences&lt;/code&gt;(Mac cmd + ，)找到&lt;code&gt;Build, Exception, Deployme&lt;/code&gt;下的&lt;code&gt;compiler&lt;/code&gt;,单击&lt;code&gt;Compiler&lt;/code&gt;,在右边&lt;code&gt;Build project automatically&lt;/code&gt;选项框内打勾。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/public-blog/img/posts/spring-devtools1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="java" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/java/"/>
    
    
      <category term="java" scheme="https://egsee.github.io/tags/java/"/>
    
      <category term="springboot" scheme="https://egsee.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS精要讲解</title>
    <link href="https://egsee.github.io/posts/1a14933b/"/>
    <id>https://egsee.github.io/posts/1a14933b/</id>
    <published>2021-06-23T05:01:01.000Z</published>
    <updated>2021-12-02T09:45:31.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><blockquote><p>HTTPS是HTTP基于TLS/SSL安全套阶层的安全通信标准，关于它的定义、结构不在本文讨论范围之内，HTTPS的精髓在于理解它是如何工作的，在这一点上网上多数博文长篇阔论，给人一种好像看了很多，但还是在很多细节上没有彻底理解的错觉。而本文主要就是要解决这些细节问题。</p></blockquote><h2 id="场景需求"><a href="#场景需求" class="headerlink" title="场景需求"></a>场景需求</h2><p>阮一峰 在自己的博文 <a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">什么是数字签名</a> 非常形象的引用了一个场景，在看本篇文章之前，建议先阅读此篇博文。</p><h2 id="HTTPS通信过程"><a href="#HTTPS通信过程" class="headerlink" title="HTTPS通信过程"></a>HTTPS通信过程</h2><p>HTTPS使用了<code>对称加密</code>、<code>非对称加密</code>、<code>哈希算法</code>三种算法用于保证通信数据的安全，下面简要说明为什么这样</p><ul><li><strong>对称加密</strong><br>因为 对称加密 相对于 非对称加密 加密速度更快，为了保证效率使用了对称加密。</li><li><strong>非对称加密</strong><br>非对称加密较之对称加密更安全，所以HTTPS使用非对称加密来进行部分初始化加密。</li><li><strong>哈希算法</strong><br>哈希主要用来做数字签名，签名能保证数据不被篡改。  </li></ul><p>由此可见，HTTPS结合了以上几种优点，在安全的同时保证了效率。</p><a id="more"></a><h3 id="交流过程"><a href="#交流过程" class="headerlink" title="交流过程"></a>交流过程</h3><p><strong>1. 客户端请求服务器（比如: <a href="https://egsee.com）。">https://egsee.com）。</a></strong><br><strong>2. 服务器收到客户端请求后，会将自己由<code>CA</code>颁发的数字证书返回给客户端。</strong><br><strong>3. 客户端收到证书后，浏览器会根据自己或系统自带的受信任的<code>CA</code>机构验证数字证书是否受信任，然后会使用CA对应公钥解密证书（也称根证书），从而拿到了服务器的公钥，然后用服务器的公钥加密通信明文生成数字摘要，对比服务器生成的数字签名以确定拿到的数据未被篡改。（此步骤客户端通过CA的参与安全的拿到了服务器的公钥）</strong><br><strong>4. 客户端用服务器的公钥加密一个伪随机数 充当 （以后对成加密需要使用的对称加密公钥），并将加密后的公钥（也称为会话密钥）发送给服务器。</strong><br><strong>5. 服务器拿到加密后的会话密钥，用自己的私钥解密后得倒会话密钥。然后使用会话密钥加密明文内容，返回给客户端。</strong><br><strong>6. 客户端和服务端通过新密钥进行安全通信。</strong></p><h2 id="如何生成服务器证书？"><a href="#如何生成服务器证书？" class="headerlink" title="如何生成服务器证书？"></a>如何生成服务器证书？</h2><p>可参照我的另一片文章 <a href="/public-blog/8e14ac7c">使用OpenSSL自签名证书</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>数字签名</code>其实就是为了保证双方通信而使用了哈希算法，以确保收到的内容不被篡改。<br>但是中途可能有人伪造了你以为对的加密公钥，会造成和 <code>&quot;假的对方&quot;</code> 通信。<br>为了解决这个问题就引入了一个<code>权威的中间人（CA）</code>做证明，证明后的可信公钥就叫<code>数字证书</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;HTTPS是HTTP基于TLS/SSL安全套阶层的安全通信标准，关于它的定义、结构不在本文讨论范围之内，HTTPS的精髓在于理解它是如何工作的，在这一点上网上多数博文长篇阔论，给人一种好像看了很多，但还是在很多细节上没有彻底理解的错觉。而本文主要就是要解决这些细节问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;场景需求&quot;&gt;&lt;a href=&quot;#场景需求&quot; class=&quot;headerlink&quot; title=&quot;场景需求&quot;&gt;&lt;/a&gt;场景需求&lt;/h2&gt;&lt;p&gt;阮一峰 在自己的博文 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html&quot;&gt;什么是数字签名&lt;/a&gt; 非常形象的引用了一个场景，在看本篇文章之前，建议先阅读此篇博文。&lt;/p&gt;
&lt;h2 id=&quot;HTTPS通信过程&quot;&gt;&lt;a href=&quot;#HTTPS通信过程&quot; class=&quot;headerlink&quot; title=&quot;HTTPS通信过程&quot;&gt;&lt;/a&gt;HTTPS通信过程&lt;/h2&gt;&lt;p&gt;HTTPS使用了&lt;code&gt;对称加密&lt;/code&gt;、&lt;code&gt;非对称加密&lt;/code&gt;、&lt;code&gt;哈希算法&lt;/code&gt;三种算法用于保证通信数据的安全，下面简要说明为什么这样&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对称加密&lt;/strong&gt;&lt;br&gt;因为 对称加密 相对于 非对称加密 加密速度更快，为了保证效率使用了对称加密。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非对称加密&lt;/strong&gt;&lt;br&gt;非对称加密较之对称加密更安全，所以HTTPS使用非对称加密来进行部分初始化加密。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希算法&lt;/strong&gt;&lt;br&gt;哈希主要用来做数字签名，签名能保证数据不被篡改。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此可见，HTTPS结合了以上几种优点，在安全的同时保证了效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="https://egsee.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="https" scheme="https://egsee.github.io/tags/https/"/>
    
      <category term="tls/ssl" scheme="https://egsee.github.io/tags/tls-ssl/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot报错&quot;Whitelabel Error Page&quot;</title>
    <link href="https://egsee.github.io/posts/f9569758/"/>
    <id>https://egsee.github.io/posts/f9569758/</id>
    <published>2021-06-21T11:13:16.000Z</published>
    <updated>2021-11-09T17:03:23.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天在调试Spring的时候出现了一个”<code>Whitelabel Error Page</code>“页面，如图</p></blockquote><p><img src="/public-blog/img/posts/whitespace.png" alt=""></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="Spring无法找到对应controller"><a href="#Spring无法找到对应controller" class="headerlink" title="Spring无法找到对应controller"></a>Spring无法找到对应<code>controller</code></h3><p>主应用程序(<code>Main application class</code>)默认情况下只会扫描到同一包下的<code>class</code>文件 <a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using.structuring-your-code">官方文档说明</a>。</p><a id="more"></a><p><img src="/public-blog/img/posts/componentScan.png" alt=""><br>所以解决方法有两个：<br>1.将<code>controller</code>写在Main application class同包下。<br>2.在Main application class下使用<code>@ComponentScan</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(basePackages=&#123;<span class="string">"com.egsee.demo"</span>&#125;)  </span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Demo1Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="书写错误"><a href="#书写错误" class="headerlink" title="书写错误"></a>书写错误</h3><p>因为我是个springboot初学者，在<code>Main Application Class</code>下定义了一个方法，想在浏览器下访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/"</span>, produces = <span class="string">"text/plain;charset=UTF-8"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Spring Boot!"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是我并没有在类中写<code>@ResetController</code>这种类似的注解，导致报错，加上注解后运行成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Application</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天在调试Spring的时候出现了一个”&lt;code&gt;Whitelabel Error Page&lt;/code&gt;“页面，如图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/public-blog/img/posts/whitespace.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h2&gt;&lt;h3 id=&quot;Spring无法找到对应controller&quot;&gt;&lt;a href=&quot;#Spring无法找到对应controller&quot; class=&quot;headerlink&quot; title=&quot;Spring无法找到对应controller&quot;&gt;&lt;/a&gt;Spring无法找到对应&lt;code&gt;controller&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;主应用程序(&lt;code&gt;Main application class&lt;/code&gt;)默认情况下只会扫描到同一包下的&lt;code&gt;class&lt;/code&gt;文件 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using.structuring-your-code&quot;&gt;官方文档说明&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="java" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/java/"/>
    
    
      <category term="java" scheme="https://egsee.github.io/tags/java/"/>
    
      <category term="springboot" scheme="https://egsee.github.io/tags/springboot/"/>
    
      <category term="debug" scheme="https://egsee.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot提示&quot;Cannot resolve symbol RestController&quot;</title>
    <link href="https://egsee.github.io/posts/8d993f72/"/>
    <id>https://egsee.github.io/posts/8d993f72/</id>
    <published>2021-06-17T11:13:16.000Z</published>
    <updated>2021-11-09T17:03:23.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在用<code>maven</code>生成<code>springboot</code>项目时，会报一个Cannot resolve symbol RestController的简单错误，但是对于初学者来说，Java的重量级配置错误常常会让人抓狂，这里记录如何解决这个报错。</p></blockquote><h2 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h2><h3 id="未引入相关依赖"><a href="#未引入相关依赖" class="headerlink" title="未引入相关依赖"></a>未引入相关依赖</h3><p>这是最常见的原因，<code>@ResetController</code>定义在<code>springboot</code>中的<code>spring-boot-starter-web</code>这个<code>artifact</code>中,但是我的<code>pom.xml</code>里已经有了这个依赖却依然报错。</p><h3 id="缓存出错"><a href="#缓存出错" class="headerlink" title="缓存出错"></a>缓存出错</h3><p>由于之前<code>idea</code>可能发生配置错误，编辑器缓存了一些配置，导致idea一直提示此错误，我就是这种情况，折腾了很久才发现这个问题。<br>方法是点击菜单中的<code>&quot;File&quot; &gt;&gt; &quot;Invalidate Caches&quot; &gt;&gt; 勾选&quot;file system cache and local history&quot;</code>确定后重启<code>idea</code>报错消失。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在用&lt;code&gt;maven&lt;/code&gt;生成&lt;code&gt;springboot&lt;/code&gt;项目时，会报一个Cannot resolve symbol RestController的简单错误，但是对于初学者来说，Java的重量级配置错误常常会让人
      
    
    </summary>
    
    
      <category term="后端" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="java" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/java/"/>
    
    
      <category term="java" scheme="https://egsee.github.io/tags/java/"/>
    
      <category term="springboot" scheme="https://egsee.github.io/tags/springboot/"/>
    
      <category term="debug" scheme="https://egsee.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Vscode Could not create temporary directory</title>
    <link href="https://egsee.github.io/posts/e5e74770/"/>
    <id>https://egsee.github.io/posts/e5e74770/</id>
    <published>2021-06-02T12:13:16.000Z</published>
    <updated>2021-11-13T08:06:52.778Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown <span class="variable">$USER</span> ~/Library/Caches/com.microsoft.VSCode.ShipIt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="片段" scheme="https://egsee.github.io/categories/%E7%89%87%E6%AE%B5/"/>
    
    
      <category term="vscode" scheme="https://egsee.github.io/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>Servlet Filter示例</title>
    <link href="https://egsee.github.io/posts/a35e20e9/"/>
    <id>https://egsee.github.io/posts/a35e20e9/</id>
    <published>2021-05-08T12:13:16.000Z</published>
    <updated>2021-11-13T08:06:52.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TODO&quot;&gt;&lt;a href=&quot;#TODO&quot; class=&quot;headerlink&quot; title=&quot;TODO&quot;&gt;&lt;/a&gt;TODO&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="片段" scheme="https://egsee.github.io/categories/%E7%89%87%E6%AE%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言常用类型占用大小</title>
    <link href="https://egsee.github.io/posts/79491f72/"/>
    <id>https://egsee.github.io/posts/79491f72/</id>
    <published>2021-04-02T12:13:16.000Z</published>
    <updated>2021-11-13T08:06:52.777Z</updated>
    
    <content type="html"><![CDATA[<h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><p>现代操作系统中，<code>int</code>一般占用<code>4</code>个字节(Byte), 共32位。若不考虑正负数，<br>当所有的位都为 1 时它的值最大，为 232-1 = 4,294,967,295 ≈ 43亿。<br><strong>int建议为一个机器字长，32位机器字长为4字节，64位机器字长为8字节</strong><br>16位环境下,int为2字节。</p><h3 id="short"><a href="#short" class="headerlink" title="short"></a>short</h3><p>短整型，占用2个字节</p><h3 id="long"><a href="#long" class="headerlink" title="long"></a>long</h3><p>长整型，16位和32位为4字节。</p><h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><p>占用1个字节</p><h3 id="64位环境占用字节情况"><a href="#64位环境占用字节情况" class="headerlink" title="64位环境占用字节情况"></a>64位环境占用字节情况</h3><p>操作系统    short    int    long<br>Win64        2        4       4<br>类Unix系统 2       4      8</p><h3 id="获取某数据类型长度："><a href="#获取某数据类型长度：" class="headerlink" title="获取某数据类型长度："></a>获取某数据类型长度：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    short a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">100</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> short_length = <span class="keyword">sizeof</span> a;</span><br><span class="line">    <span class="keyword">int</span> int_length = <span class="keyword">sizeof</span>(b);</span><br><span class="line">    <span class="keyword">int</span> long_length = <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">int</span> char_length = <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"short=%d, int=%d, long=%d, char=%d\n"</span>, short_length, int_length, long_length, char_length);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 32 位环境以及 Win64 环境下的运行结果<br>short=2, int=4, long=4, char=1<br>// 64 位 Linux 和 Mac OS 下的运行结果<br>short=2, int=4, long=8, char=1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;int&quot;&gt;&lt;a href=&quot;#int&quot; class=&quot;headerlink&quot; title=&quot;int&quot;&gt;&lt;/a&gt;int&lt;/h3&gt;&lt;p&gt;现代操作系统中，&lt;code&gt;int&lt;/code&gt;一般占用&lt;code&gt;4&lt;/code&gt;个字节(Byte), 共32位。若不考虑正负数，
      
    
    </summary>
    
    
      <category term="片段" scheme="https://egsee.github.io/categories/%E7%89%87%E6%AE%B5/"/>
    
    
      <category term="c/c++" scheme="https://egsee.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>Git Submodule 简单使用</title>
    <link href="https://egsee.github.io/posts/8e690a6a/"/>
    <id>https://egsee.github.io/posts/8e690a6a/</id>
    <published>2021-03-20T10:00:01.000Z</published>
    <updated>2021-11-09T17:03:23.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><blockquote><p>URL由多部分构成，不同的语言解析URL函数得到的名称并不完全相同，恰巧在网上看到一篇不错关于URL组成的图形化描述，在此记录。</p></blockquote><h2 id="URL组成"><a href="#URL组成" class="headerlink" title="URL组成"></a>URL组成</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"https://bob:bobby@www.lunatech.com:8080/file;p=1?q=2#third"</span></span><br></pre></td></tr></table></figure><p>一个这样的URL，可以提取到以下信息：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+---------------------+</span><br><span class="line">|        Part       |       Data          |</span><br><span class="line">+-------------------+---------------------+</span><br><span class="line">|  Scheme           | https               |</span><br><span class="line">|  User             | bob                 |</span><br><span class="line">|  Password         | bobby               |</span><br><span class="line">|  Host             | www.lunatech.com    |</span><br><span class="line">|  Port             | 8080                |</span><br><span class="line">|  Path             | /file;p=1           |</span><br><span class="line">|  Path parameter   | p=1                 |</span><br><span class="line">|  Query            | q=2                 |</span><br><span class="line">|  Fragment         | third               |</span><br><span class="line">+-------------------+---------------------+</span><br><span class="line"></span><br><span class="line">https://bob:bobby@www.lunatech.com:8080/file;p=1?q=2<span class="comment">#third</span></span><br><span class="line">\___/   \_/ \___/ \______________/ \__/\_______/ \_/ \___/</span><br><span class="line">  |      |    |          |          |      | \_/  |    |</span><br><span class="line">Scheme User Password    Host       Port  Path |   | Fragment</span><br><span class="line">        \_____________________________/       | Query</span><br><span class="line">                       |               Path parameter</span><br><span class="line">                   Authority</span><br></pre></td></tr></table></figure><a id="more"></a><p>使用nodejs <code>URL</code>函数打印的URL信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> url = <span class="string">"https://bob:bobby@www.lunatech.com:8080/file;p=1?q=2#third"</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">new</span> URL(url)</span><br><span class="line">URL &#123;</span><br><span class="line">  href: <span class="string">'https://bob:bobby@www.lunatech.com:8080/file;p=1?q=2#third'</span>,</span><br><span class="line">  origin: <span class="string">'https://www.lunatech.com:8080'</span>,</span><br><span class="line">  protocol: <span class="string">'https:'</span>,</span><br><span class="line">  username: <span class="string">'bob'</span>,</span><br><span class="line">  password: <span class="string">'bobby'</span>,</span><br><span class="line">  host: <span class="string">'www.lunatech.com:8080'</span>,</span><br><span class="line">  hostname: <span class="string">'www.lunatech.com'</span>,</span><br><span class="line">  port: <span class="string">'8080'</span>,</span><br><span class="line">  pathname: <span class="string">'/file;p=1'</span>,</span><br><span class="line">  search: <span class="string">'?q=2'</span>,</span><br><span class="line">  searchParams: URLSearchParams &#123; <span class="string">'q'</span> =&gt; <span class="string">'2'</span> &#125;,</span><br><span class="line">  hash: <span class="string">'#third'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20">Url encoding the space character or %20</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;URL由多部分构成，不同的语言解析URL函数得到的名称并不完全相同，恰巧在网上看到一篇不错关于URL组成的图形化描述，在此记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;URL组成&quot;&gt;&lt;a href=&quot;#URL组成&quot; class=&quot;headerlink&quot; title=&quot;URL组成&quot;&gt;&lt;/a&gt;URL组成&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;https://bob:bobby@www.lunatech.com:8080/file;p=1?q=2#third&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;一个这样的URL，可以提取到以下信息：&lt;/p&gt;
&lt;figure class=&quot;highlight zsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+-------------------+---------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|        Part       |       Data          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-------------------+---------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  Scheme           | https               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  User             | bob                 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  Password         | bobby               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  Host             | www.lunatech.com    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  Port             | 8080                |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  Path             | /file;p=1           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  Path parameter   | p=1                 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  Query            | q=2                 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  Fragment         | third               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-------------------+---------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https://bob:bobby@www.lunatech.com:8080/file;p=1?q=2&lt;span class=&quot;comment&quot;&gt;#third&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\___/   \_/ \___/ \______________/ \__/\_______/ \_/ \___/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  |      |    |          |          |      | \_/  |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Scheme User Password    Host       Port  Path |   | Fragment&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        \_____________________________/       | Query&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       |               Path parameter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   Authority&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="https://egsee.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="https://egsee.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用OpenSSL自签名证书</title>
    <link href="https://egsee.github.io/posts/8e14ac7c/"/>
    <id>https://egsee.github.io/posts/8e14ac7c/</id>
    <published>2021-03-17T05:01:21.000Z</published>
    <updated>2021-11-09T17:03:23.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><blockquote><p>网上关于自签证书的博客资料可以说是很多了，但其中的很多写的都是含糊不清的，此篇文章将会尽量清晰的描述自签名证书和创建CA为自己的服务器颁发证书。</p></blockquote><h2 id="什么是数字证书和数字签名"><a href="#什么是数字证书和数字签名" class="headerlink" title="什么是数字证书和数字签名"></a>什么是数字证书和数字签名</h2><p>对于这个问题，阮一峰有一篇 <strong><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">文章</a></strong> 比较形象的解释了这个问题，此处，我们主要记录如何生成。</p><h2 id="创建CA颁发数字证书"><a href="#创建CA颁发数字证书" class="headerlink" title="创建CA颁发数字证书"></a>创建CA颁发数字证书</h2><p>要给我们的服务器颁发一个<code>数字证书</code>，我们首先需要自己创建一个证书颁发机构 <code>CA</code> ，通常情况下，这个CA是真实的颁发机构，我们使用Chrome访问的<code>https</code>网页时会出现一把锁，这些都是真实的CA颁发的，因此浏览器对此是信任的。</p><p></p><p><strong>为CA生成一个长度为1024的私钥</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out ca.key <span class="number">1024</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>生成CA机构自己的证书申请文件(.csr)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -<span class="keyword">new</span> -key ca.key -out ca.csr</span><br></pre></td></tr></table></figure><p><strong>使用私钥和证书申请文件为CA生成一个自己签名的证书，俗称自签名证书，这里也叫根证书</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt</span><br></pre></td></tr></table></figure><blockquote><p>第二个命令中，<code>req</code>是一个<code>openssl</code>的一个关于证书请求文件的子命令，可以运行<code>openssl req --help</code>查看帮助。最后一个命令的<code>x509</code>是在 <strong><a href="https://baike.baidu.com/item/ASN.1/498523">ASN.1</a></strong> 中定义的 <strong><a href="https://baike.baidu.com/item/X.509/2817050">一种格式</a></strong>，X.509证书里含有公钥、身份信息(比如网络主机名，组织的名称或个体名称等)和签名信息(可以是证书签发机构CA的签名，也可以是自签名)，证书的拥有者就可以用证书及相应的私钥来创建安全的通信，对文档进行数字签名。<br>在nginx使用https，nginx配置好后只需将<code>ca.crt</code>颁发给客户端电脑，客户端电脑信任后，浏览器浏览即可看到一把绿锁状态。</p></blockquote><h3 id="生成服务器私钥"><a href="#生成服务器私钥" class="headerlink" title="生成服务器私钥"></a>生成服务器私钥</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server.key 1024</span><br></pre></td></tr></table></figure><h3 id="生成服务器证书申请文件"><a href="#生成服务器证书申请文件" class="headerlink" title="生成服务器证书申请文件"></a>生成服务器证书申请文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr</span><br></pre></td></tr></table></figure><h3 id="使用CA证书签名服务器证书文件"><a href="#使用CA证书签名服务器证书文件" class="headerlink" title="使用CA证书签名服务器证书文件"></a>使用CA证书签名服务器证书文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> server.csr -out server.crt -CA ca.crt -CAkey ca.key -CAcreateserial</span><br></pre></td></tr></table></figure><h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><p>自签名证书顾名思义无需CA参与，自己给自己颁发一个证书，流程相对简单</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server.key 1024</span><br><span class="line">openssl req -new -key server.key -out server.csr</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> server.csr -signkey server.key -out ca.crt</span><br></pre></td></tr></table></figure><p>也可以省略生成密钥过程，让系统自动生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -nodes -days 365 -newkey rsa:1024 \</span><br><span class="line">-keyout &#x2F;tmp&#x2F;server.key -out &#x2F;tmp&#x2F;server.crt</span><br></pre></td></tr></table></figure><blockquote><p><code>-nodes</code> 选项禁止加密私钥文件。<br><code>-days</code> 指定过期时间</p></blockquote><p>然后输入一些信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Country Name (2 letter code) [AU]:</span><br><span class="line">State or Province Name (full name) [Some-State]:</span><br><span class="line">Locality Name (eg, city) []:</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:</span><br><span class="line">Organizational Unit Name (eg, section) []:</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []: 这个是你的域名或ip</span><br><span class="line">Email Address []:</span><br></pre></td></tr></table></figure><p>另外也可以只省略证书请求文件，让系统在签署过程中在内存中自动创建证书请求文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -key pri.pem -out server.crt -days 365</span><br></pre></td></tr></table></figure><p>这样一个证书就申请好了。</p><h2 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h2><h3 id="查看证书申请文件"><a href="#查看证书申请文件" class="headerlink" title="查看证书申请文件"></a>查看证书申请文件</h3><p>一个服务器申请文件可通过<code>openssl req -in req1.csr -noout -text</code>来输出文件头部分，如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Certificate Request:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 0 (0x0)</span><br><span class="line">        Subject: C=AU, ST=Some-State, O=Internet Widgits Pty Ltd //个人信息</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption  //使用的公钥算法</span><br><span class="line">                Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:cf:a2:a6:65:ab:e0:38:73:25:8c:d6:33:94:ba:</span><br><span class="line">                    d9:4f:6c:93:28:bc:05:81:b9:4c:07:02:93:e2:07:</span><br><span class="line">                    c3:0f:57:92:ad:16:e9:57:6f:05:93:44:66:5b:2a:</span><br><span class="line">                    1a:54:5f:80:96:3f:b0:5a:b6:fe:70:fb:a1:4d:f5:</span><br><span class="line">                    cf:d3:fb:10:ec:8a:1c:3b:53:6c:dd:49:a8:d7:61:</span><br><span class="line">                    52:b9:9d:06:e3:94:7a:6f:73:4d:f6:7d:7b:ad:55:</span><br><span class="line">                    bf:85:28:0d:8c:dc:50:72:5d:bb:9d:f8:ed:2a:18:</span><br><span class="line">                    82:f2:03:b6:00:61:7f:ad:ea:36:57:00:8e:77:df:</span><br><span class="line">                    06:00:97:d3:fe:09:35:a6:3d:0d:47:71:24:03:26:</span><br><span class="line">                    3b:b6:37:f3:24:1d:d9:2f:c7:d8:7e:d2:db:08:b2:</span><br><span class="line">                    49:35:6d:4c:d2:d6:57:0d:e8:6f:4c:ae:5e:50:1c:</span><br><span class="line">                    f4:bf:42:df:f1:fb:19:88:eb:0f:05:ad:69:32:da:</span><br><span class="line">                    89:2e:ef:61:e2:95:58:11:27:ba:1c:9f:f4:7f:83:</span><br><span class="line">                    03:de:2f:a6:73:2b:18:b5:46:82:c5:8b:85:19:c0:</span><br><span class="line">                    f4:25:d4:d8:ad:b6:81:9f:e1:b2:6d:ab:eb:ef:ba:</span><br><span class="line">                    2d:f3:06:fa:65:54:8c:14:81:65:4b:d2:48:b4:32:</span><br><span class="line">                    fd:ae:f7:71:6d:8e:dc:9d:a6:87:47:ee:a7:11:3f:</span><br><span class="line">                    ab:a9</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        Attributes:</span><br><span class="line">            a0:00</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption   //请求文件使用的数字签名算法</span><br><span class="line">         95:68:5f:6a:6e:f0:b6:7c:bc:97:c7:c5:ce:76:c0:a8:3f:2a:</span><br><span class="line">         07:61:5f:75:ee:f0:c3:73:51:c9:b9:d7:59:68:67:06:ca:e5:</span><br><span class="line">         a8:d3:68:19:32:27:ff:18:5f:4b:eb:02:6f:7c:f6:85:db:76:</span><br><span class="line">         36:56:90:3f:b6:f9:45:4a:1a:4c:74:a9:28:b1:f9:e9:f2:af:</span><br><span class="line">         2e:4f:d6:38:d5:72:b0:ba:11:36:92:55:9c:a3:48:61:6f:66:</span><br><span class="line">         73:7b:f6:35:91:cf:8a:23:aa:e1:e1:fd:ed:b1:ea:78:6c:0d:</span><br><span class="line">         1b:bf:6c:19:4c:a7:1c:dc:09:bb:a5:3f:2f:b2:aa:77:cb:d5:</span><br><span class="line">         2b:e4:57:bc:14:14:7d:ed:ec:a3:d5:b4:50:93:d3:b0:3a:07:</span><br><span class="line">         49:0b:fa:e7:42:b8:a6:bf:39:ae:bf:c6:66:37:f3:40:2b:59:</span><br><span class="line">         75:ce:c4:08:f4:b1:18:2c:48:17:a8:2c:6d:41:1e:5a:a8:86:</span><br><span class="line">         34:53:a7:ff:fd:e0:95:64:b7:69:9b:86:b7:66:4d:db:74:dc:</span><br><span class="line">         c6:52:18:e9:dc:2a:b0:b1:f9:33:10:a8:d6:0d:1a:ef:0c:ac:</span><br><span class="line">         1b:<span class="built_in">fc</span>:c7:61:30:ab:80:01:62:21:06:f1:7b:a7:0c:7c:bf:20:</span><br><span class="line">         e8:d2:b6:24:a3:9a:93:ae:94:02:cf:06:23:74:1f:54:ec:16:</span><br><span class="line">         a7:7e:44:b4</span><br></pre></td></tr></table></figure><p>输出subject部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -in req.csr -subject -noout</span><br></pre></td></tr></table></figure><p>使用<code>-pubkey</code>输出请求文件中的公钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -in req1.csr -pubkey -noout</span><br></pre></td></tr></table></figure><p>如果是从申请证书请求时所提供的私钥中提取出公钥，那么以下输出的公钥和上面相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in server.key -pubout</span><br></pre></td></tr></table></figure><h3 id="指定证书请求文件中的签名算法"><a href="#指定证书请求文件中的签名算法" class="headerlink" title="指定证书请求文件中的签名算法"></a>指定证书请求文件中的签名算法</h3><p>如果不指定此项，默认为<code>sha256</code>，也支持其它很多签名算法，可以通过使用<code>openssl dgst --help</code>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr -md5</span><br><span class="line">openssl req -in server.csr -noout -text | grep Algo</span><br></pre></td></tr></table></figure><h3 id="验证请求文件的数字签名（验证文件是否被篡改）"><a href="#验证请求文件的数字签名（验证文件是否被篡改）" class="headerlink" title="验证请求文件的数字签名（验证文件是否被篡改）"></a>验证请求文件的数字签名（验证文件是否被篡改）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -verify -in server.csr &#x2F;&#x2F;未被篡改会打印verify OK</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;网上关于自签证书的博客资料可以说是很多了，但其中的很多写的都是含糊不清的，此篇文章将会尽量清晰的描述自签名证书和创建CA为自己的服务器颁发证书。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是数字证书和数字签名&quot;&gt;&lt;a href=&quot;#什么是数字证书和数字签名&quot; class=&quot;headerlink&quot; title=&quot;什么是数字证书和数字签名&quot;&gt;&lt;/a&gt;什么是数字证书和数字签名&lt;/h2&gt;&lt;p&gt;对于这个问题，阮一峰有一篇 &lt;strong&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html&quot;&gt;文章&lt;/a&gt;&lt;/strong&gt; 比较形象的解释了这个问题，此处，我们主要记录如何生成。&lt;/p&gt;
&lt;h2 id=&quot;创建CA颁发数字证书&quot;&gt;&lt;a href=&quot;#创建CA颁发数字证书&quot; class=&quot;headerlink&quot; title=&quot;创建CA颁发数字证书&quot;&gt;&lt;/a&gt;创建CA颁发数字证书&lt;/h2&gt;&lt;p&gt;要给我们的服务器颁发一个&lt;code&gt;数字证书&lt;/code&gt;，我们首先需要自己创建一个证书颁发机构 &lt;code&gt;CA&lt;/code&gt; ，通常情况下，这个CA是真实的颁发机构，我们使用Chrome访问的&lt;code&gt;https&lt;/code&gt;网页时会出现一把锁，这些都是真实的CA颁发的，因此浏览器对此是信任的。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;为CA生成一个长度为1024的私钥&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;openssl genrsa -out ca.key &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="https://egsee.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="https://egsee.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="密码学" scheme="https://egsee.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>XSS攻击介绍</title>
    <link href="https://egsee.github.io/posts/ec76a593/"/>
    <id>https://egsee.github.io/posts/ec76a593/</id>
    <published>2021-03-01T15:01:26.000Z</published>
    <updated>2021-11-09T17:03:23.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><blockquote><p>XSS 攻击是非常常见的网页攻击了，网上有很多资料，但我始终想写一个简单的总结。</p></blockquote><h2 id="何为-XSS"><a href="#何为-XSS" class="headerlink" title="何为 XSS?"></a>何为 XSS?</h2><p>XSS(Cross site script)指利用浏览器的特性，像指定网页提交特殊字符造成浏览器解析运行的一种攻击手段。XSS 有几种，个人觉得记这些意义不大，因此这里不再赘述，有兴趣的朋友可以在网上搜一下。</p><h2 id="如何产生-XSS"><a href="#如何产生-XSS" class="headerlink" title="如何产生 XSS"></a>如何产生 XSS</h2><p>XSS 攻击主要来自于用户的输入，如果你的站点存在着 XSS 漏洞，那么用户就可以进行 XSS 攻击，通过运行脚本代码，用户可以获取譬如 Cookie 等较为敏感的信息。</p><h2 id="一个-XSS-攻击的例子"><a href="#一个-XSS-攻击的例子" class="headerlink" title="一个 XSS 攻击的例子"></a>一个 XSS 攻击的例子</h2><p>这里我引用<a href="https://learnku.com/">LearnKu</a>的两张图来说明 XSS 攻击事如何发生的<br>在原文中，作者使用了 所见即所得 编辑器，指出虽然所见即所得编辑器过滤了特殊的字符，但依然可能发生 XSS 攻击，原因在于非法用户可能通过其它手段提交数据：</p><ul><li><strong>使用 Chrome devtools 提交数据 刷新页面发生 XSS 攻击</strong></li></ul><p><img src="/public-blog/img/posts/xss-demo1.gif" alt="xss-demo-1"></p><a id="more"></a><ul><li><strong>数据库已经有了特殊字符的数据</strong></li></ul><p><img src="/public-blog/img/posts/xss-demo2.gif" alt="xss-demo-2"></p><p>Chrome Devtools 示例攻击提交</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"http://xss.test/demo"</span>, &#123;</span><br><span class="line">    headers: &#123; <span class="string">"content-type"</span>: <span class="string">"application/x-www-form-urlencoded"</span>, <span class="string">"upgrade-insecure-requests"</span>: <span class="string">"1"</span> &#125;,</span><br><span class="line">    body:</span><br><span class="line">        <span class="string">"_token=AGL1jSjzX152b71UEAQiTzwbYdRGYnECRI17WRiG&amp;title=dangerous%20content+&amp;category_id=2&amp;body=%3Cscript%3Ealert%28%27%E5%AD%98%E5%9C%A8%20XSS%20%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%EF%BC%81%27%29%3C%2Fscript%3E"</span>,</span><br><span class="line">    method: <span class="string">"POST"</span>,</span><br><span class="line">    mode: <span class="string">"cors"</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="监测XSS漏洞"><a href="#监测XSS漏洞" class="headerlink" title="监测XSS漏洞"></a>监测XSS漏洞</h2><p>可以使用<a href="https://github.com/0xsobky/HackVault/wiki/Unleashing-an-Ultimate-XSS-Polyglot">XSS Polylot</a>监测XSS漏洞，文章进行了说明并有很多demo.<br>也可以使用一些第三方检测工具<a href="https://github.com/Arachni/arachni">Arachni</a>、<a href="https://github.com/mozilla/http-observatory/">http-observatory</a></p><h2 id="防范-XSS-攻击"><a href="#防范-XSS-攻击" class="headerlink" title="防范 XSS 攻击"></a>防范 XSS 攻击</h2><p>以上的例子说明，虽然各种开源的编辑器已经做了 XSS 过滤，但依然发生 XSS 攻击，这是因为后端和网页展示没有对 XSS 做过滤，因此需要前后端都对特殊字符进行过滤，以确保没有 XSS 漏洞。<br>XSS 攻击的本质是浏览器解析了特殊字符的脚本，因此我们只需要在用户输入、页面展示、参数传输这些地方过滤这些特殊字符就可以了：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字符转义后的字符</span><br><span class="line">&amp; =&gt; &amp;amp;</span><br><span class="line">&lt; =&gt; &amp;lt;</span><br><span class="line">&gt; =&gt; &amp;gt;</span><br><span class="line"><span class="string">" =&gt; &amp;quot;</span></span><br><span class="line"><span class="string">' =&gt; &amp;#x27;</span></span><br><span class="line"><span class="string">/ =&gt; &amp;#x2F;</span></span><br></pre></td></tr></table></figure><p>同时JS中应注意使用<code>innerHTML</code>,<code>outerHTML</code>，如果使用他们渲染，将有可能出现XSS漏洞。  如果使用了React、Vue等框架，使用<code>v-html</code>,<code>dangerouslySetInnerHTML</code>也应小心谨慎。</p><ul><li><strong>使用JQuery</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> $(<span class="string">'&lt;div/&gt;'</span>).text(t).html();</span><br></pre></td></tr></table></figure></li><li><strong>prototype.js的escabeHTML()</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHTML</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">      .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">      .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>Underscope中的escape</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List of HTML entities for escaping.</span></span><br><span class="line"><span class="keyword">var</span> htmlEscapes = &#123;</span><br><span class="line">  <span class="string">'&amp;'</span>: <span class="string">'&amp;amp;'</span>,</span><br><span class="line">  <span class="string">'&lt;'</span>: <span class="string">'&amp;lt;'</span>,</span><br><span class="line">  <span class="string">'&gt;'</span>: <span class="string">'&amp;gt;'</span>,</span><br><span class="line">  <span class="string">'"'</span>: <span class="string">'&amp;quot;'</span>,</span><br><span class="line">  <span class="string">"'"</span>: <span class="string">'&amp;#x27;'</span>,</span><br><span class="line">  <span class="string">'/'</span>: <span class="string">'&amp;#x2F;'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Regex containing the keys listed immediately above.</span></span><br><span class="line"><span class="keyword">var</span> htmlEscaper = <span class="regexp">/[&amp;&lt;&gt;"'\/]/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Escape a string for HTML interpolation.</span></span><br><span class="line">_.escape = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">''</span> + string).replace(htmlEscaper, <span class="function"><span class="keyword">function</span>(<span class="params">match</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> htmlEscapes[match];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// examples</span></span><br><span class="line">_.escape(<span class="string">'Curly, Larry &amp; Moe'</span>);</span><br><span class="line"><span class="comment">// =&gt; "Curly, Larry &amp;amp; Moe"</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="其它安全措施"><a href="#其它安全措施" class="headerlink" title="其它安全措施"></a>其它安全措施</h2><ul><li><strong>使用Content Security Policy</strong><br><a href="https://www.ruanyifeng.com/blog/2016/09/csp.html">CSP</a>是一个浏览器的特性，能从根本上解决XSS漏洞问题</li><li><strong>设置Cookie为HTTP-only</strong><br>这可能防止部分信息泄漏</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://coderwall.com/p/ostduq/escape-html-with-javascript">Escape HTML with Javascript</a><br><a href="https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20">URL encoding the space character + or %20</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;XSS 攻击是非常常见的网页攻击了，网上有很多资料，但我始终想写一个简单的总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;何为-XSS&quot;&gt;&lt;a href=&quot;#何为-XSS&quot; class=&quot;headerlink&quot; title=&quot;何为 XSS?&quot;&gt;&lt;/a&gt;何为 XSS?&lt;/h2&gt;&lt;p&gt;XSS(Cross site script)指利用浏览器的特性，像指定网页提交特殊字符造成浏览器解析运行的一种攻击手段。XSS 有几种，个人觉得记这些意义不大，因此这里不再赘述，有兴趣的朋友可以在网上搜一下。&lt;/p&gt;
&lt;h2 id=&quot;如何产生-XSS&quot;&gt;&lt;a href=&quot;#如何产生-XSS&quot; class=&quot;headerlink&quot; title=&quot;如何产生 XSS&quot;&gt;&lt;/a&gt;如何产生 XSS&lt;/h2&gt;&lt;p&gt;XSS 攻击主要来自于用户的输入，如果你的站点存在着 XSS 漏洞，那么用户就可以进行 XSS 攻击，通过运行脚本代码，用户可以获取譬如 Cookie 等较为敏感的信息。&lt;/p&gt;
&lt;h2 id=&quot;一个-XSS-攻击的例子&quot;&gt;&lt;a href=&quot;#一个-XSS-攻击的例子&quot; class=&quot;headerlink&quot; title=&quot;一个 XSS 攻击的例子&quot;&gt;&lt;/a&gt;一个 XSS 攻击的例子&lt;/h2&gt;&lt;p&gt;这里我引用&lt;a href=&quot;https://learnku.com/&quot;&gt;LearnKu&lt;/a&gt;的两张图来说明 XSS 攻击事如何发生的&lt;br&gt;在原文中，作者使用了 所见即所得 编辑器，指出虽然所见即所得编辑器过滤了特殊的字符，但依然可能发生 XSS 攻击，原因在于非法用户可能通过其它手段提交数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用 Chrome devtools 提交数据 刷新页面发生 XSS 攻击&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/public-blog/img/posts/xss-demo1.gif&quot; alt=&quot;xss-demo-1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="https://egsee.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="https://egsee.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="网络安全" scheme="https://egsee.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>escape、encodeURI和encodeURIComponent的区别</title>
    <link href="https://egsee.github.io/posts/8312df14/"/>
    <id>https://egsee.github.io/posts/8312df14/</id>
    <published>2021-02-21T05:01:16.000Z</published>
    <updated>2021-11-13T08:06:52.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><blockquote><p>简要记录了<code>escape</code>,<code>encdoeURI</code>,<code>encodeURIComponent</code>的区别。</p></blockquote><h3 id="escape【已弃用】"><a href="#escape【已弃用】" class="headerlink" title="escape【已弃用】"></a>escape【已弃用】</h3><p>对字符串进行unicode编码,编码出来的类似%uxx格式，其中ASCII字母、数字、@*/+ 这些字符不会编码。</p><blockquote><p>该函数已弃用，不建议使用</p></blockquote><h3 id="encodeURI"><a href="#encodeURI" class="headerlink" title="encodeURI"></a>encodeURI</h3><p>编码URI的函数，它主要适用于将一个完整的URI进行UTF8编码:<br>encodeURI(<a href="https://egsee.com/?id=1&amp;name=egsee#+section)。">https://egsee.com/?id=1&amp;name=egsee#+section)。</a></p><h3 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent"></a>encodeURIComponent</h3><p>适用于编码一个查询querystring，然后将起组装在URI上，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> world = <span class="string">"A string with symbols &amp; characters that have special meaning?"</span>;</span><br><span class="line"><span class="keyword">var</span> uri = <span class="string">'http://example.com/foo?hello='</span> + <span class="built_in">encodeURIComponent</span>(world);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Char  encUrI  encURIComp  escape</span><br><span class="line">*     *       *           *</span><br><span class="line">.     .       .           .</span><br><span class="line">_     _       _           _</span><br><span class="line">-     -       -           -</span><br><span class="line">~     ~       ~           %7E</span><br><span class="line">&#39;     &#39;       &#39;           %27</span><br><span class="line">!     !       !           %21</span><br><span class="line">(     (       (           %28</span><br><span class="line">)     )       )           %29</span><br><span class="line">&#x2F;     &#x2F;       %2F         &#x2F;</span><br><span class="line">+     +       %2B         +</span><br><span class="line">@     @       %40         @</span><br><span class="line">?     ?       %3F         %3F</span><br><span class="line">&#x3D;     &#x3D;       %3D         %3D</span><br><span class="line">:     :       %3A         %3A</span><br><span class="line">#     #       %23         %23</span><br><span class="line">;     ;       %3B         %3B</span><br><span class="line">,     ,       %2C         %2C</span><br><span class="line">$     $       %24         %24</span><br><span class="line">&amp;     &amp;       %26         %26</span><br><span class="line">      %20     %20         %20</span><br><span class="line">%     %25     %25         %25</span><br><span class="line">^     %5E     %5E         %5E</span><br><span class="line">[     %5B     %5B         %5B</span><br><span class="line">]     %5D     %5D         %5D</span><br><span class="line">&#123;     %7B     %7B         %7B</span><br><span class="line">&#125;     %7D     %7D         %7D</span><br><span class="line">&lt;     %3C     %3C         %3C</span><br><span class="line">&gt;     %3E     %3E         %3E</span><br><span class="line">&quot;     %22     %22         %22</span><br><span class="line">\     %5C     %5C         %5C</span><br><span class="line">|     %7C     %7C         %7C</span><br><span class="line">&#96;     %60     %60         %60</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.tutorialspoint.com/html/html_url_encoding.htm">HTML - URL Encoding</a><br><a href="https://stackoverflow.com/questions/4540753/should-i-use-encodeuri-or-encodeuricomponent-for-encoding-urls#:~:text=%20%20%201%20encodeURI%20is%20used%20to,encodeURI%2C%20but%20encoded%20by%20encodeURIComponent.%20List%3A%20More%20">Should I use encodeURI or encodeURIComponent for encoding URLs?</a><br><a href="https://stackoverflow.com/questions/14317861/difference-between-escape-encodeuri-encodeuricomponent">Difference between escape(), encodeURI(), encodeURIComponent()</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;简要记录了&lt;code&gt;escape&lt;/code&gt;,&lt;code&gt;encdoeURI&lt;/code&gt;,&lt;code&gt;encodeURIComponent&lt;/code&gt;的区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;escape【已弃用】&quot;&gt;&lt;a href=&quot;#escape【已弃用】&quot; class=&quot;headerlink&quot; title=&quot;escape【已弃用】&quot;&gt;&lt;/a&gt;escape【已弃用】&lt;/h3&gt;&lt;p&gt;对字符串进行unicode编码,编码出来的类似%uxx格式，其中ASCII字母、数字、@*/+ 这些字符不会编码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该函数已弃用，不建议使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;encodeURI&quot;&gt;&lt;a href=&quot;#encodeURI&quot; class=&quot;headerlink&quot; title=&quot;encodeURI&quot;&gt;&lt;/a&gt;encodeURI&lt;/h3&gt;&lt;p&gt;编码URI的函数，它主要适用于将一个完整的URI进行UTF8编码:&lt;br&gt;encodeURI(&lt;a href=&quot;https://egsee.com/?id=1&amp;amp;name=egsee#+section)。&quot;&gt;https://egsee.com/?id=1&amp;amp;name=egsee#+section)。&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;encodeURIComponent&quot;&gt;&lt;a href=&quot;#encodeURIComponent&quot; class=&quot;headerlink&quot; title=&quot;encodeURIComponent&quot;&gt;&lt;/a&gt;encodeURIComponent&lt;/h3&gt;&lt;p&gt;适用于编码一个查询querystring，然后将起组装在URI上，如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; world = &lt;span class=&quot;string&quot;&gt;&quot;A string with symbols &amp;amp; characters that have special meaning?&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; uri = &lt;span class=&quot;string&quot;&gt;&#39;http://example.com/foo?hello=&#39;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;encodeURIComponent&lt;/span&gt;(world);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="https://egsee.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="https://egsee.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Chrome资源覆盖率</title>
    <link href="https://egsee.github.io/posts/deac4cd7/"/>
    <id>https://egsee.github.io/posts/deac4cd7/</id>
    <published>2021-02-17T05:01:21.000Z</published>
    <updated>2021-11-09T17:03:23.269Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><blockquote><p>我们经常在Chrome里面调试网页，以下演示了如何查看脚本资源代码的使用率</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a><video src="/public-blog/video/coverage.mov" muted="" loop="" playsinline="" preload="auto" autoplay="autoplay"></video></h2><p>可以看到演示中的<code>Unused Bytes</code>是很高的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;我们经常在Chrome里面调试网页，以下演示了如何查看脚本资源代码的使用率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
    
      <category term="调试工具" scheme="https://egsee.github.io/categories/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="调试工具" scheme="https://egsee.github.io/tags/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>C/C++编译过程</title>
    <link href="https://egsee.github.io/posts/e58902ff/"/>
    <id>https://egsee.github.io/posts/e58902ff/</id>
    <published>2021-02-03T05:01:16.000Z</published>
    <updated>2021-11-09T17:03:23.268Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预处理-预编译"><a href="#预处理-预编译" class="headerlink" title="预处理/预编译"></a>预处理/预编译</h3><p>对目标代码进行文本处理和翻译，包括：</p><p>头部文件(<code>#include</code>)<br>条件编译指令(<code>#ifdef、#endif</code>等)、宏(<code>#define</code>)<br>删除注释<br>添加行号和文件名标识  </p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //预编译处理</span></span></span><br><span class="line"><span class="comment">// #define DEBUG //预编译处理</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your name:"</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hey!"</span> &lt;&lt; name &lt;&lt; <span class="string">"Welcome to my blog\n"</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG <span class="comment">//预编译处理</span></span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>预处理字符都是以#开头</p></blockquote><a id="more"></a><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译将原文件<code>.cpp</code>编译为汇编语言，这一步主要做语法分析、检查语法是否错误、词法分析产生汇编文件。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>讲编译完的文件翻译成机器码，每一条汇编几乎可以直接翻译成一条对应的机器指令，这一步无需语义分析和优化，生成的<code>.o</code>或<code>.obj</code>后缀的二进制对象文件。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接是将生成的一个或者多个中间的文件联合生成可执行文件。链接程序的各个目标文件和库文件<code>(.a)</code>，成为一个能被操作系统执行的可执行文件。</p><h2 id="g-相关命令"><a href="#g-相关命令" class="headerlink" title="g++相关命令"></a>g++相关命令</h2><p>Preprocessing - 由预处理器cpp完成，得到<code>.i</code>后缀的文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E demo.cpp -o demo.i</span><br></pre></td></tr></table></figure><p>Compilation - 由编译器ccplus完成，得到<code>.s</code>后缀的汇编文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S demo.i -o demo.s</span><br></pre></td></tr></table></figure><p>Assembly - 由汇编器as处理，得到<code>.o</code>的二进制目标文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c demo.s -o demo.o</span><br></pre></td></tr></table></figure><p>Linking - 链接器ld来完成，将二进制文件链接后得到可执行文件<code>.out</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ demo.o -o demo.out</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;预处理-预编译&quot;&gt;&lt;a href=&quot;#预处理-预编译&quot; class=&quot;headerlink&quot; title=&quot;预处理/预编译&quot;&gt;&lt;/a&gt;预处理/预编译&lt;/h3&gt;&lt;p&gt;对目标代码进行文本处理和翻译，包括：&lt;/p&gt;
&lt;p&gt;头部文件(&lt;code&gt;#include&lt;/code&gt;)&lt;br&gt;条件编译指令(&lt;code&gt;#ifdef、#endif&lt;/code&gt;等)、宏(&lt;code&gt;#define&lt;/code&gt;)&lt;br&gt;删除注释&lt;br&gt;添加行号和文件名标识  &lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt; //预编译处理&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// #define DEBUG //预编译处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Enter your name:&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Hey!&quot;&lt;/span&gt; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Welcome to my blog\n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifdef&lt;/span&gt; DEBUG &lt;span class=&quot;comment&quot;&gt;//预编译处理&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;预处理字符都是以#开头&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="c/c++" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/c-c/"/>
    
    
      <category term="c/c++" scheme="https://egsee.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>HTTP Headers之Referer</title>
    <link href="https://egsee.github.io/posts/30eac58d/"/>
    <id>https://egsee.github.io/posts/30eac58d/</id>
    <published>2021-01-17T05:01:21.000Z</published>
    <updated>2021-11-09T17:03:23.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><blockquote><p>本文主要记录一下 Headers 中 Referer 和 Referrer-Policy 等相关字段介绍</p></blockquote><h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><blockquote><p>Referer 字段标记了访问来源，广泛应用于分析、日志、优化缓存等作用。<br>Referer 字段是 Referrer 单词的错误拼写，由于历史原因沿用至今。<br>当点击一个链接的时候，<code>Referer</code>包含了拥有这个链接的页面地址，而在对其它域名发起资源请求时，则包含了请求页面的地址。</p></blockquote><a id="more"></a><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p><code>Referer</code>由 <code>origin, path, querystring</code>字段构成，<code>fragment</code>(e.g. “#section”) 或者 <code>username:password</code> 信息将不会包含在其中。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>Referer: <code>&lt;url&gt;</code></p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>“<a href="https://username:password@example.com/foo/bar/&quot;将不会包含在Referer中">https://username:password@example.com/foo/bar/&quot;将不会包含在Referer中</a><br>诸如一下的例子会包含在 Referer 中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Referer: https:<span class="comment">//developer.mozilla.org/en-US/docs/Web/JavaScript</span></span><br><span class="line">Referer: https:<span class="comment">//example.com/page?q=123</span></span><br><span class="line">Referer: https:<span class="comment">//example.com/</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：Referer 可能包含以上域名的全部或部分，这取决于 <a href="#Referrer-Policy">Referrer Policy</a></p></blockquote><h2 id="Referrer-Policy"><a href="#Referrer-Policy" class="headerlink" title="Referrer-Policy"></a>Referrer-Policy</h2><p>Referrer-Policy 字段主要控制将要展示哪些 Referer 信息</p><p>有一下几个选项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Referrer-Policy: no-referrer</span><br><span class="line">Referrer-Policy: no-referrer-when-downgrade</span><br><span class="line">Referrer-Policy: origin</span><br><span class="line">Referrer-Policy: origin-when-cross-origin</span><br><span class="line">Referrer-Policy: same-origin</span><br><span class="line">Referrer-Policy: strict-origin</span><br><span class="line">Referrer-Policy: strict-origin-when-cross-origin</span><br><span class="line">Referrer-Policy: unsafe-url</span><br></pre></td></tr></table></figure><ul><li><strong>no-referrer</strong><br>省略 Referer 字段，发送请求将不会包含任何头字段</li><li><strong>no-referrer-when-downgrade</strong><br>这个选项的主要意思是当从 https 访问到 http 中时不展示 referer 信息</li><li><strong>origin</strong><br>只展示 Origin</li><li><strong>origin-when-cross-origin</strong><br>表示同源且相同级别协议（https =&gt; https, http =&gt; http）下，展示 Referer 所有信息，但在跨域和降级（https =&gt; http）访问时只展示 origin 信息。</li><li><strong>same-origin</strong><br>仅在同源下展示 referer 信息</li><li><strong>strict-origin</strong><br>仅在安全(https)协议下展示 referer 信息</li><li><strong>strict-origin-when-cross-origin (默认)</strong><br>同源请求展示全部 referer 信息, 跨域请求且安全协议下（https =&gt; https）仅展示 origin</li><li><strong>unsafe-url</strong><br>任何情况下都展示完整 referer</li></ul><h3 id="在-HTML-里设置-referer-Policy-信息"><a href="#在-HTML-里设置-referer-Policy-信息" class="headerlink" title="在 HTML 里设置 referer Policy 信息"></a>在 HTML 里设置 referer Policy 信息</h3><p>也可以在 HTML 中设置 referer 策略信息，如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"referrer"</span> <span class="attr">content</span>=<span class="string">"origin"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>&lt;a&gt;, &lt;area&gt;, &lt;img&gt;, &lt;iframe&gt;, &lt;script&gt;, &lt;link&gt;</code> 标签中可以使用<code>referrerpolicy</code>选项设置 referer policy 信息：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span> <span class="attr">referrerpolicy</span>=<span class="string">"origin"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者在一个 a, area, 或 link 元素中设置 <code>rel</code> 为 noreferer</p><blockquote><p>注意：上面的 noreferrer 链接关系是不带破折号的。当您使用 <code>&lt;meta&gt;</code> 元素为整个文档指定引用策略时，应使用短划线编写：<code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;</code>。</p></blockquote><h3 id="与-CSS-集成"><a href="#与-CSS-集成" class="headerlink" title="与 CSS 集成"></a>与 CSS 集成</h3><p>CSS 可以从样式表中获取引用的资源。这些资源也遵循推荐人政策：</p><ul><li>外部 CSS 样式表使用默认策略 (strict-origin-when-cross-origin)，除非它被 CSS 样式表响应中的 Referrer-Policy HTTP 标头覆盖。</li><li>对于 <code>&lt;style&gt;</code> 元素或样式属性，使用所有者文档的引用策略。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#integration_with_html">Referrer-Policy</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer">Referer</a><br><a href="https://www.ruanyifeng.com/blog/2016/09/csp.html">Content Security Policy 入门教程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要记录一下 Headers 中 Referer 和 Referrer-Policy 等相关字段介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Referer&quot;&gt;&lt;a href=&quot;#Referer&quot; class=&quot;headerlink&quot; title=&quot;Referer&quot;&gt;&lt;/a&gt;Referer&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Referer 字段标记了访问来源，广泛应用于分析、日志、优化缓存等作用。&lt;br&gt;Referer 字段是 Referrer 单词的错误拼写，由于历史原因沿用至今。&lt;br&gt;当点击一个链接的时候，&lt;code&gt;Referer&lt;/code&gt;包含了拥有这个链接的页面地址，而在对其它域名发起资源请求时，则包含了请求页面的地址。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="https://egsee.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="headers" scheme="https://egsee.github.io/tags/headers/"/>
    
  </entry>
  
</feed>
