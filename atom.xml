<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EGSEE</title>
  
  <subtitle>SmallHouse</subtitle>
  <link href="/public-blog/atom.xml" rel="self"/>
  
  <link href="https://egsee.github.io/"/>
  <updated>2021-10-27T16:35:38.937Z</updated>
  <id>https://egsee.github.io/</id>
  
  <author>
    <name>egsee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NPM Workspaces简介</title>
    <link href="https://egsee.github.io/posts/923ed035/"/>
    <id>https://egsee.github.io/posts/923ed035/</id>
    <published>2021-09-01T11:13:16.000Z</published>
    <updated>2021-10-27T16:35:38.937Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>npm在2020年10月发布的版本开始支持一个新功能：Workspaces</p></blockquote><h3 id="Workspaces是什么？"><a href="#Workspaces是什么？" class="headerlink" title="Workspaces是什么？"></a>Workspaces是什么？</h3><p><code>Workspaces</code>即工作区，可以帮我们管理包含多个<code>包（package）</code>的项目，这些项目（称为monorepo）可能包含多个<code>package.json</code>，而Workspaces可以方便的对这类项目进行管理。</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>一个简单的多包依赖项目的例子如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── index.js</span><br><span class="line">├── package.json</span><br><span class="line">└── packages</span><br><span class="line">    ├── packageA</span><br><span class="line">    │   ├── index.js</span><br><span class="line">    │   └── package.json # Dependencies: `vuepress`,`packageB`</span><br><span class="line">    └── packageB</span><br><span class="line">        ├── index.js</span><br><span class="line">        └── package.json # Dependencies: `vuepress`, `packageA`</span><br></pre></td></tr></table></figure><p>当我们在根目录运行<code>npm install</code> 或 <code>yarn install</code>的时候，npm会在根文件的<code>node_modules</code>下创建彼此的符号链接，以便package能够引入，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules # 根文件 node_modules</span><br><span class="line">│   ├── vuepress # 依赖的vuepress</span><br><span class="line">│   ├── packageA # 符号链接包A</span><br><span class="line">│   └── packageB # 符号链接包B</span><br></pre></td></tr></table></figure><h3 id="配置和使用"><a href="#配置和使用" class="headerlink" title="配置和使用"></a>配置和使用</h3><p>在根项目目录下的<code>packages.json</code>中配置<code>workspaces</code>关键字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"workspaces"</span>: [</span><br><span class="line">    <span class="string">"packages/*"</span>,</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>子包中的<code>package.json</code>添加<code>dependencies</code>对其它包的依赖<br>然后运行npm，则可以在子包中非常方便的使用本地依赖库了。</p><h3 id="其它用法"><a href="#其它用法" class="headerlink" title="其它用法"></a>其它用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Run "test" script on all packages</span><br><span class="line">npm run test --workspaces</span><br><span class="line">npm run test  -ws</span><br><span class="line"></span><br><span class="line"># Runs "test" only on packageA</span><br><span class="line">npm run test --workspace packageA</span><br><span class="line">npm run test -w packageB</span><br><span class="line"></span><br><span class="line"># Install `lodash` on `packageA`</span><br><span class="line">npm install lodash --workspace packageA</span><br><span class="line"></span><br><span class="line"># Install `tap` on `packageB` as a dev dependency</span><br><span class="line">npm install tap --workspace packageB --save-dev</span><br><span class="line"></span><br><span class="line"># Install `packageA` on `packageB`</span><br><span class="line">npm install packageA --workspace packageB</span><br><span class="line"></span><br><span class="line"># Install `eslint` in all packages</span><br><span class="line">npm install eslint --workspaces</span><br></pre></td></tr></table></figure><h3 id="npm-工作区-与-Yarn-工作区"><a href="#npm-工作区-与-Yarn-工作区" class="headerlink" title="npm 工作区 与 Yarn 工作区"></a>npm 工作区 与 Yarn 工作区</h3><p>Yarn中也有命令来管理workspaces,<br>例如： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn workspace &lt;workspace&gt; add &lt;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="使用-Lerna"><a href="#使用-Lerna" class="headerlink" title="使用 Lerna"></a>使用 Lerna</h3><p>使用 npm workspaces 和 yarn workspaces 虽然可以管理一些monorepos<br>但对于一些更大的项目来说，它包含更多的依赖树，这时可能就要使用类似<a href="https://github.com/lerna/lerna">Lerna</a>这样的管理工具了。<br>Lerna 有很多命令来管理大型的monorepo。<br>在<a href="https://github.com/vuepress/vuepress-next">VuePress</a>项目中结合使用了这两个功能，读者可以参考其用法。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://docs.npmjs.com/cli/v7/using-npm/workspaces">NPM Workspaces</a><br><a href="https://ruanmartinelli.com/posts/npm-7-workspaces-1">Getting Started with npm Workspaces</a><br><a href="https://github.com/vuepress/vuepress-next">Vuepress repository</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;npm在2020年10月发布的版本开始支持一个新功能：Workspaces&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Workspaces是什么？&quot;&gt;&lt;a href=&quot;#Workspaces是什么？&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="前端" scheme="https://egsee.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="npm" scheme="https://egsee.github.io/tags/npm/"/>
    
      <category term="packages.json" scheme="https://egsee.github.io/tags/packages-json/"/>
    
      <category term="workspaces" scheme="https://egsee.github.io/tags/workspaces/"/>
    
  </entry>
  
  <entry>
    <title>Git Submodule 简单使用</title>
    <link href="https://egsee.github.io/posts/8e690a6a/"/>
    <id>https://egsee.github.io/posts/8e690a6a/</id>
    <published>2020-12-17T05:01:16.000Z</published>
    <updated>2021-10-27T16:33:13.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><blockquote><p>有时候我们需要在一个项目中依赖一个更新中的公共库，或者在一个大型仓库中给不同的开发人员分配各自独立的仓库，这个时候Git的子模块就很有用了。</p></blockquote><h3 id="添加一个子模块"><a href="#添加一个子模块" class="headerlink" title="添加一个子模块"></a>添加一个子模块</h3><p>我们假设你已经创建了一个远端仓库<code>greet.git</code><br>那么可以添加这个仓库到主项目，使之成为一个子模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add &lt;remote_url&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure><p>添加子模块并切换分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add -b &lt;branch&gt; &lt;url&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 添加远程greet仓库到当前项目为greet子模块</span><br><span class="line">git submodule add https://github.com/&lt;username&gt;/greet.git greet</span><br></pre></td></tr></table></figure><p>此时在主项目中会多处一个<code>.gitmodules</code>的文件记录子模块的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;greet&quot;]</span><br><span class="line">path &#x3D; greet</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;&lt;username&gt;&#x2F;greet.git</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="初始化和拉取子模块更新"><a href="#初始化和拉取子模块更新" class="headerlink" title="初始化和拉取子模块更新"></a>初始化和拉取子模块更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 拉取主repo和子repo --&gt;</span><br><span class="line">git clone main --recursive</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;main_repository&gt;</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure><h3 id="批量操作所有子模块"><a href="#批量操作所有子模块" class="headerlink" title="批量操作所有子模块"></a>批量操作所有子模块</h3><p>可以使用<code>git submodule foreach [--recursive] &lt;git command&gt;</code>对所有子模块进行批量操作, 如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule foreach git pull</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;有时候我们需要在一个项目中依赖一个更新中的公共库，或者在一个大型仓库中给不同的开发人员分配各自独立的仓库，这个时候Git的子模块就很有用了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;添加一个子模块&quot;&gt;&lt;a href=&quot;#添加一个子模块&quot; class=&quot;headerlink&quot; title=&quot;添加一个子模块&quot;&gt;&lt;/a&gt;添加一个子模块&lt;/h3&gt;&lt;p&gt;我们假设你已经创建了一个远端仓库&lt;code&gt;greet.git&lt;/code&gt;&lt;br&gt;那么可以添加这个仓库到主项目，使之成为一个子模块：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git submodule add &amp;lt;remote_url&amp;gt; &amp;lt;path&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;添加子模块并切换分支：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git submodule add -b &amp;lt;branch&amp;gt; &amp;lt;url&amp;gt; &amp;lt;path&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;举例：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 添加远程greet仓库到当前项目为greet子模块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git submodule add https://github.com/&amp;lt;username&amp;gt;/greet.git greet&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此时在主项目中会多处一个&lt;code&gt;.gitmodules&lt;/code&gt;的文件记录子模块的信息：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[submodule &amp;quot;greet&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	path &amp;#x3D; greet&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	url &amp;#x3D; https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;&amp;lt;username&amp;gt;&amp;#x2F;greet.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="开发工具" scheme="https://egsee.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="https://egsee.github.io/tags/git/"/>
    
      <category term="github" scheme="https://egsee.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>memset替换字符串的注意点</title>
    <link href="https://egsee.github.io/posts/d8689c7b/"/>
    <id>https://egsee.github.io/posts/d8689c7b/</id>
    <published>2020-10-17T11:13:16.000Z</published>
    <updated>2021-10-20T15:24:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串只读"><a href="#字符串只读" class="headerlink" title="字符串只读"></a>字符串只读</h2><ul><li><p>memset 原型<br><code>void * memset( void * ptr, int value, size_t num )</code></p><blockquote><p>其中 size_t 即是 unsigned int</p></blockquote></li><li><p>参数说明<br>ptr 为要操作的内存的指针。<br>value 为要设置的值。你既可以向 value 传递 int 类型的值，也可以传递 char 类型的值，因为 int 和 char 可以根据 ASCII 码相互转换。<br>num 为 ptr 的前 num 个字节。</p><blockquote><p>注意：参数 value 虽声明为 int，但必须是 unsigned char，所以范围在0 到255 之间。</p></blockquote></li></ul><a id="more"></a><ul><li>使用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"https://github.com"</span>;</span><br><span class="line">    <span class="built_in">memset</span>(str, <span class="string">'-'</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出 ——-github.com</p></blockquote><ul><li>错误使用<br>由于字符串是只读的，不能被修改。而memset必须修改目标，所以不能直接将字符指针直接指向字符串，以下使用将在运行时报错</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"https://github.com"</span>;</span><br><span class="line">    <span class="built_in">memset</span>(str, <span class="string">'-'</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bus error: 10</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字符串只读&quot;&gt;&lt;a href=&quot;#字符串只读&quot; class=&quot;headerlink&quot; title=&quot;字符串只读&quot;&gt;&lt;/a&gt;字符串只读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;memset 原型&lt;br&gt;&lt;code&gt;void * memset( void * ptr, int value, size_t num )&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中 size_t 即是 unsigned int&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参数说明&lt;br&gt;ptr 为要操作的内存的指针。&lt;br&gt;value 为要设置的值。你既可以向 value 传递 int 类型的值，也可以传递 char 类型的值，因为 int 和 char 可以根据 ASCII 码相互转换。&lt;br&gt;num 为 ptr 的前 num 个字节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：参数 value 虽声明为 int，但必须是 unsigned char，所以范围在0 到255 之间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="c/c++" scheme="https://egsee.github.io/tags/c-c/"/>
    
      <category term="内存" scheme="https://egsee.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>C内存分配</title>
    <link href="https://egsee.github.io/posts/a1501c1d/"/>
    <id>https://egsee.github.io/posts/a1501c1d/</id>
    <published>2020-09-17T11:13:16.000Z</published>
    <updated>2021-10-20T15:23:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C 内存分配主要有 malloc、calloc、realoc 三个函数，以下简要介绍</p></blockquote><h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><p>内存里主要有几个划分，用一张表格表示<br>| 内存分区 | 内容 | 权限 |<br>| ———- | ——————– | ——– |<br>| 栈区 | 函数中的普通变量 | 可读可写 |<br>| 堆区 | 动态申请的内存 | 可读可写 |<br>| 静态变量区 | static 修饰的变量 | 可读可写 |<br>| 数据区 | 用于初始化变量的常量 | 只读 |<br>| 代码区 | 代码指令 | 只读 |</p><h2 id="malloc、calloc、realoc"><a href="#malloc、calloc、realoc" class="headerlink" title="malloc、calloc、realoc"></a>malloc、calloc、realoc</h2><p>C\C++允许我们使用这三个函数直接操作内存，具体就是对堆（Heap）的操作，那么这几种有哪些不同呢？</p><a id="more"></a><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><ul><li>函数原型<br><code>void* malloc (size_t size);</code></li><li>头文件<br><code>头文件：#include &lt;stdlib.h&gt;</code></li><li>说明<br><code>malloc</code>在 Heap 区域分配一块长度为<code>size</code>字节的连续区域并返回该区域的地址，malloc() 函数不能为所分配的空间初始化值，需要使用 memset()，。在程序结束前，需要使用 free() 进行内存释放。</li><li>例子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p  = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p); <span class="comment">//输出100</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><blockquote><p>注意： memset 只能给 int 类型赋值的范围为 0x00 - 0xff (即 0 - 255)，超过将按位赋值。<a href="/posts/d8689c7b#字符串只读">memset 使用介绍&gt;&gt;</a></p></blockquote><h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h3><ul><li>函数原型<br><code>void* calloc (size_t num, size_t size)</code></li><li>头文件<br><code>#include &lt;stdlib.h&gt;</code></li><li>说明<br><code>calloc</code>和<code>malloc</code>类似，在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0。</li><li>使用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr = (<span class="keyword">char</span> *)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="number">10</span>);  <span class="comment">// 分配100个字节的内存空间</span></span><br></pre></td></tr></table></figure><blockquote><p>注意 由于返回的指针类型未知，所以在使用 calloc() 时通常需要进行强制类型转换，将 void 指针转换成我们希望的类型。</p></blockquote><ul><li>比较<br>以下两种使用等效</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str1 = (<span class="keyword">char</span> *)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// malloc() 分配内存空间并用 memset() 初始化</span></span><br><span class="line"><span class="keyword">char</span> *str2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">memset</span>(str2, <span class="number">0</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h3 id="realoc"><a href="#realoc" class="headerlink" title="realoc"></a>realoc</h3><ul><li>函数原型<br><code>void* realloc (void* ptr, size_t size)</code></li><li>头文件<br><code>#include &lt;stdlib.h&gt;</code></li><li>说明<br>ptr 为需要重新分配的内存空间指针，size 为新的内存空间的大小，<code>relloc</code>为指定内存指针的动态内存（通常指 malloc 和 calloc 分配的）重新分配大小。</li><li>注意</li></ul><ol><li>如果 ptr 为 NULL，它的效果和 malloc() 相同，即分配 size 字节的内存空间。</li><li>如果 size 的值为 0，那么 ptr 指向的内存空间就会被释放，但是由于没有开辟新的内存空间，所以会返回空指针，类似于调用 free()。</li><li>指针 ptr 必须是在动态内存空间分配成功的指针，形如如下的指针是不可以的：int *i; int a[2]；会导致运行时错误，可以简单的这样记忆：用 malloc()、calloc()、realloc() 分配成功的指针才能被 realloc() 函数接受。</li><li>成功分配内存后 ptr 将被系统回收，不可再对 ptr 指针做任何操作，包括 free()。相反的，可以对 realloc() 函数的返回值进行正常操作。</li><li>如果是扩大内存操作会把 ptr 指向的内存中的数据复制到新地址（新地址也可能会和原地址相同，但依旧不能对原指针进行任何操作）；如果是缩小内存操作，原始据会被复制并截取新长度。</li></ol><ul><li>返回值<br>分配成功返回新的内存地址，可能与 ptr 相同，也可能不同。失败则返回 NULL。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 5</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(SIZE, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">int</span> *rp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩容为之前的两倍</span></span><br><span class="line"><span class="comment">// 注意这里使用了新指针(rp)而不是(p)，可在realloc分配失败时，防止p指向的内存泄漏</span></span><br><span class="line">rp = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(p, SIZE * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">free</span>(rp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>malloc</code> 和 <code>colloc</code> 都是动态分配内存，但colloc会在初始化的同时将每个字节的内存值初始化为0。</li><li><code>realoc</code> 主要功能是对 <code>malloc</code> 和 <code>colloc</code> 分配的内存容量进行调整。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;C 内存分配主要有 malloc、calloc、realoc 三个函数，以下简要介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;内存分区&quot;&gt;&lt;a href=&quot;#内存分区&quot; class=&quot;headerlink&quot; title=&quot;内存分区&quot;&gt;&lt;/a&gt;内存分区&lt;/h2&gt;&lt;p&gt;内存里主要有几个划分，用一张表格表示&lt;br&gt;| 内存分区 | 内容 | 权限 |&lt;br&gt;| ———- | ——————– | ——– |&lt;br&gt;| 栈区 | 函数中的普通变量 | 可读可写 |&lt;br&gt;| 堆区 | 动态申请的内存 | 可读可写 |&lt;br&gt;| 静态变量区 | static 修饰的变量 | 可读可写 |&lt;br&gt;| 数据区 | 用于初始化变量的常量 | 只读 |&lt;br&gt;| 代码区 | 代码指令 | 只读 |&lt;/p&gt;
&lt;h2 id=&quot;malloc、calloc、realoc&quot;&gt;&lt;a href=&quot;#malloc、calloc、realoc&quot; class=&quot;headerlink&quot; title=&quot;malloc、calloc、realoc&quot;&gt;&lt;/a&gt;malloc、calloc、realoc&lt;/h2&gt;&lt;p&gt;C\C++允许我们使用这三个函数直接操作内存，具体就是对堆（Heap）的操作，那么这几种有哪些不同呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="c/c++ 内存" scheme="https://egsee.github.io/tags/c-c-%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>nodejs垃圾回收</title>
    <link href="https://egsee.github.io/posts/e0a6bc82/"/>
    <id>https://egsee.github.io/posts/e0a6bc82/</id>
    <published>2020-09-17T11:13:16.000Z</published>
    <updated>2021-10-20T15:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>内存泄漏是一个老生常谈的问题，由于多数语言已经有了GC回收，且现代计算机有了更大的内存，所以不少工程师对于这方面并不太了解，今天主要谈一谈nodejs的垃圾回收机制。</p></blockquote><h2 id="如何发生内存泄漏"><a href="#如何发生内存泄漏" class="headerlink" title="如何发生内存泄漏"></a>如何发生内存泄漏</h2><p>c语言没有GC，每次分配内存需要程序员手动操作释放，这里使用一个简单c的例子来说明什么是内存泄漏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义两个指针分别指向两块内存</span></span><br><span class="line"><span class="keyword">char</span> * p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">char</span> * p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//将p1指向p2指向的内存</span></span><br><span class="line">p1 = p2</span><br></pre></td></tr></table></figure><blockquote><p>当p1指向p2指向的内存的时候，p1原来的那部分内存就无法操作也没有回收，这好像‘没有了’一样，这种情况就发生了内存泄漏</p></blockquote><a id="more"></a><h3 id="正常模式和精简模式"><a href="#正常模式和精简模式" class="headerlink" title="正常模式和精简模式"></a>正常模式和精简模式</h3><p><code>hexo框架2仓2主题</code>，采用正常模式一个仓库，一个主题；精简模式另一个仓库，另一个主题。</p><p>本博客采用的github Page部署网站。大家都知道，一个github的账户名，只能够指定一个<code>username.github.io</code>的网址，所以两个仓库，两个主题的话，就必须有一个挂在<code>username.github.io</code>之上，比如正常模式<code>username.github.io</code>，精简模式为<code>username.github.io/name.io</code>。</p><h4 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h4><p>正常模式里面可以放各种炫酷的东西，提供丰富的页面。</p><h4 id="精简模式"><a href="#精简模式" class="headerlink" title="精简模式"></a>精简模式</h4><p>只提供必要的文章，归档，分类，搜索基本的东西就够了。看个人需要，既然要简洁，就尽量的少弄一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;内存泄漏是一个老生常谈的问题，由于多数语言已经有了GC回收，且现代计算机有了更大的内存，所以不少工程师对于这方面并不太了解，今天主要谈一谈nodejs的垃圾回收机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;如何发生内存泄漏&quot;&gt;&lt;a href=&quot;#如何发生内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;如何发生内存泄漏&quot;&gt;&lt;/a&gt;如何发生内存泄漏&lt;/h2&gt;&lt;p&gt;c语言没有GC，每次分配内存需要程序员手动操作释放，这里使用一个简单c的例子来说明什么是内存泄漏。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//定义两个指针分别指向两块内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * p1 = (&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * p2 = (&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//将p1指向p2指向的内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p1 = p2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;当p1指向p2指向的内存的时候，p1原来的那部分内存就无法操作也没有回收，这好像‘没有了’一样，这种情况就发生了内存泄漏&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://egsee.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="nodejs" scheme="https://egsee.github.io/tags/nodejs/"/>
    
      <category term="GC" scheme="https://egsee.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Gan</title>
    <link href="https://egsee.github.io/posts/7e709353/"/>
    <id>https://egsee.github.io/posts/7e709353/</id>
    <published>2020-01-21T02:14:11.000Z</published>
    <updated>2021-10-20T15:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="不好意思，密码没对哦，在检查检查呢！" data-whm="不好意思，信息无法验证！">  <script id="hbeData" type="hbeData" data-hmacdigest="0de224ed8f79dad7a3e81c591fd16ab30a8caeaec5674e6f8085700a1cd772f5">165d50f05814027fb7fe5e4ae8a088d8fd306100dc57933273cf97103a7eee23a48598ae97b555ccd9b9ed2800b66ddaae29e47149150d9d9667e55ea3307ead9107a5de9794deaac446346a6718585d9114b716a4b461f94050a385e701a7df1bf9fb9ffa0444f56b6ba7d93f9edbf33dd37994eec1695b2ec9da18317e5ebbfb8283d6762d0848b9add1784d3ccc1ad89d17ea96cd38b8ca6172a90a2c7ef9fec10d253ce8024fa2324209472cda2c6ecdfcdf66cb4bc78d072593778391a9ecc8cf67101604b423fc0f92994d0cd27acdb550b3567597564e496cadf7cd52b8a39dbb98baecf0f92b3f76745ce886415bbedb0a0a8cf3c5fc8ae8877414c9cf0df65a39548a388424f6dcabf402e05aff88f80341a1facf85b1fe833f09a45d7ea635bf5203ec4e0ee2f8804039a0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">嗨，请准确无误地输入密码查看哟（密码：123）！</span>      </label>    </div>  </div></div><script data-pjax src="/public-blog/lib/hbe.js"></script><link href="/public-blog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      看不了
    
    </summary>
    
    
      <category term="私密" scheme="https://egsee.github.io/categories/%E7%A7%81%E5%AF%86/"/>
    
    
      <category term="加密文章" scheme="https://egsee.github.io/tags/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>加密文章测试</title>
    <link href="https://egsee.github.io/posts/7e709353/"/>
    <id>https://egsee.github.io/posts/7e709353/</id>
    <published>2020-01-21T02:14:11.000Z</published>
    <updated>2021-10-20T15:22:19.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="不好意思，密码没对哦，在检查检查呢！" data-whm="不好意思，信息无法验证！">  <script id="hbeData" type="hbeData" data-hmacdigest="f0f9c9cb2c90f3c8d8b638899d3e6bab0b7028795b0f7c3f96c9f31947f55a5b">4630436162ade97ba2718b7d0c4b3b63480c11f21f943edd569d93952dd2b428ca40d00edd08503bde446612a9b43ffa557648f22736556fdb8df232a70f5b62381872db0244c43c00526e1a08cf52221edf34128af95f6689fc9f8038d2d384d80553865a152ddd5e6208a870af3b5c9bc83d20b2dbb9eed9bf4345fcbd80740d0d96973b857ce18daf962a01b68ae1d5fbd8ee95919ff5e4e59e2389903324d011f36e647c7bfde1d377a277b639b7845f1864318dedde1881f738423184c1eda461211d6767b7282687bd23a77a8725cebce8f83995baff71092164b22479</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">嗨，请准确无误地输入密码查看哟（密码：123456）！</span>      </label>    </div>  </div></div><script data-pjax src="/public-blog/lib/hbe.js"></script><link href="/public-blog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      咦，这是一篇加密文章，好像需要输入密码才能查看呢！
    
    </summary>
    
    
      <category term="私密" scheme="https://egsee.github.io/categories/%E7%A7%81%E5%AF%86/"/>
    
    
      <category term="加密文章" scheme="https://egsee.github.io/tags/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>博客换肤的一种实现方式思路</title>
    <link href="https://egsee.github.io/posts/1c5449cf/"/>
    <id>https://egsee.github.io/posts/1c5449cf/</id>
    <published>2019-09-17T11:13:16.000Z</published>
    <updated>2021-10-20T15:23:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当博客内容很多的时候，比如需要加载很多资源文件，许多炫酷的东西的时候，可能相应的就是比较慢了（正可谓时间和空间不能兼得）。虽然目前也有很多方式手段可以提高访问速度，但是博客提供一个简洁模式还是很有必要的，萝卜青菜，各有所爱嘛。说不定很多网友就当纯的想看看文字，不需要那些花里胡哨的东西。这时候提供个清爽模式就相当有用了。</p></blockquote><a id="more"></a><h3 id="正常模式和精简模式"><a href="#正常模式和精简模式" class="headerlink" title="正常模式和精简模式"></a>正常模式和精简模式</h3><p><code>hexo框架2仓2主题</code>，采用正常模式一个仓库，一个主题；精简模式另一个仓库，另一个主题。</p><p>本博客采用的github Page部署网站。大家都知道，一个github的账户名，只能够指定一个<code>username.github.io</code>的网址，所以两个仓库，两个主题的话，就必须有一个挂在<code>username.github.io</code>之上，比如正常模式<code>username.github.io</code>，精简模式为<code>username.github.io/name.io</code>。</p><h4 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h4><p>正常模式里面可以放各种炫酷的东西，提供丰富的页面。</p><h4 id="精简模式"><a href="#精简模式" class="headerlink" title="精简模式"></a>精简模式</h4><p>只提供必要的文章，归档，分类，搜索基本的东西就够了。看个人需要，既然要简洁，就尽量的少弄一些。</p><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p>关于<strong>_config.yml</strong>主配置文件的注意事项。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ root: /remove.io/ #精简模式</span></span><br><span class="line"><span class="deletion">- root: /  #正常模式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line"><span class="addition">+ repo: https://github.com/egsee/remove.io.git  #精简模式</span></span><br><span class="line"><span class="deletion">- repo: https://github.com/egsee/egsee.github.io.git  #正常模式</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ theme: icarus #正常模式</span></span><br><span class="line"><span class="deletion">- theme: nextn #精简模式</span></span><br></pre></td></tr></table></figure><p>对于root 根节点的说明，因为精简模式的所有资源文件都是挂在 username.github.io/remove.io/ 所以相当于根节点为/remove.io/ </p><h3 id="总结注意事项"><a href="#总结注意事项" class="headerlink" title="总结注意事项"></a>总结注意事项</h3><ul><li>对于页面中对于对应模式下资源文件的引用，一定加上域名地址 ，比如原来图片访问<code>/image/tuizi.jpg</code>，在精简模式的时候如果继续这样用，就找不到，对应模式下的图片了，需要加上前面的<code>username.github.io/remove.io/</code> 地址。</li><li>对于精简模式下，能去掉的东西就尽量去掉，尽量少加载一些，速度更快。</li><li>对于冲突页面的处理，一般对于文章或者关于页面都是通用。文章一般没啥影响，但是关于页面，可能有些也有很炫酷的模块。对于精简模式，可能不需要，此时就需要多new 一个page页面，分开配置，比如下面主题中的<code>_config.yml</code>配置。</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ /remove.io/abouta/ #精简模式</span></span><br><span class="line"><span class="deletion">- /abouta/ #正常模式</span></span><br></pre></td></tr></table></figure><p>本博客<a href="https://egsee.github.io/">正常模式</a></p><p><a href="https://egsee.github.io/">精简模式</a></p><p>以上只是提供了一种解决方法思路，肯定还有更好的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当博客内容很多的时候，比如需要加载很多资源文件，许多炫酷的东西的时候，可能相应的就是比较慢了（正可谓时间和空间不能兼得）。虽然目前也有很多方式手段可以提高访问速度，但是博客提供一个简洁模式还是很有必要的，萝卜青菜，各有所爱嘛。说不定很多网友就当纯的想看看文字，不需要那些花里胡哨的东西。这时候提供个清爽模式就相当有用了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具教程" scheme="https://egsee.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
      <category term="主题工具" scheme="https://egsee.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具教程" scheme="https://egsee.github.io/tags/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
