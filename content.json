{"pages":[{"title":"","text":"本站推荐索引 时间轴记录","link":"/public-blog/about/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://egsee.github.io/public-blog/images/avatar.jpg 网站名称：EGSEE 网站地址：https://egsee.github.io/public-blog 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/public-blog/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/public-blog/media/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/public-blog/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 var gitalk = new Gitalk({ clientID: 'fec450a2bb38d0063cc8', clientSecret: '24432e44cfc517df8d522a0679a34f5ada039bd9', id: '0x63cc8', repo: 'public-blog-say', owner: 'egsee', admin: \"egsee\", createIssueManually: true, distractionFreeMode: false }) gitalk.render('comment-container1')","link":"/public-blog/self-talking/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/public-blog/message/index.html"},{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/public-blog/album/index.html"}],"posts":[{"title":"Gan","text":"165d50f05814027fb7fe5e4ae8a088d8fd306100dc57933273cf97103a7eee23a48598ae97b555ccd9b9ed2800b66ddaae29e47149150d9d9667e55ea3307ead9107a5de9794deaac446346a6718585d9114b716a4b461f94050a385e701a7df1bf9fb9ffa0444f56b6ba7d93f9edbf33dd37994eec1695b2ec9da18317e5ebbfb8283d6762d0848b9add1784d3ccc1ad89d17ea96cd38b8ca6172a90a2c7ef9fec10d253ce8024fa2324209472cda2c6ecdfcdf66cb4bc78d072593778391a9ecc8cf67101604b423fc0f92994d0cd27acdb550b3567597564e496cadf7cd52b8a39dbb98baecf0f92b3f76745ce886415bbedb0a0a8cf3c5fc8ae8877414c9cf0df65a39548a388424f6dcabf402e05aff88f80341a1facf85b1fe833f09a45d7ea635bf5203ec4e0ee2f8804039a0 嗨，请准确无误地输入密码查看哟（密码：123）！","link":"/public-blog/posts/7e709353/"},{"title":"C内存分配","text":"C 内存分配主要有 malloc、calloc、realoc 三个函数，以下简要介绍 内存分区内存里主要有几个划分，用一张表格表示| 内存分区 | 内容 | 权限 || ———- | ——————– | ——– || 栈区 | 函数中的普通变量 | 可读可写 || 堆区 | 动态申请的内存 | 可读可写 || 静态变量区 | static 修饰的变量 | 可读可写 || 数据区 | 用于初始化变量的常量 | 只读 || 代码区 | 代码指令 | 只读 | malloc、calloc、realocC\\C++允许我们使用这三个函数直接操作内存，具体就是对堆（Heap）的操作，那么这几种有哪些不同呢？ malloc 函数原型void* malloc (size_t size); 头文件头文件：#include &lt;stdlib.h&gt; 说明malloc在 Heap 区域分配一块长度为size字节的连续区域并返回该区域的地址，malloc() 函数不能为所分配的空间初始化值，需要使用 memset()，。在程序结束前，需要使用 free() 进行内存释放。 例子 1234int *p = (int *) malloc(sizeof(int));memset(p, 100, 1);printf(\"%d\\n\", *p); //输出100free(p); 注意： memset 只能给 int 类型赋值的范围为 0x00 - 0xff (即 0 - 255)，超过将按位赋值。memset 使用介绍&gt;&gt; calloc 函数原型void* calloc (size_t num, size_t size) 头文件#include &lt;stdlib.h&gt; 说明calloc和malloc类似，在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0。 使用 1char *ptr = (char *)calloc(10, 10); // 分配100个字节的内存空间 注意 由于返回的指针类型未知，所以在使用 calloc() 时通常需要进行强制类型转换，将 void 指针转换成我们希望的类型。 比较以下两种使用等效 1234char *str1 = (char *)calloc(10, 2);// malloc() 分配内存空间并用 memset() 初始化char *str2 = (char *)malloc(20);memset(str2, 0, 20); realoc 函数原型void* realloc (void* ptr, size_t size) 头文件#include &lt;stdlib.h&gt; 说明ptr 为需要重新分配的内存空间指针，size 为新的内存空间的大小，relloc为指定内存指针的动态内存（通常指 malloc 和 calloc 分配的）重新分配大小。 注意 如果 ptr 为 NULL，它的效果和 malloc() 相同，即分配 size 字节的内存空间。 如果 size 的值为 0，那么 ptr 指向的内存空间就会被释放，但是由于没有开辟新的内存空间，所以会返回空指针，类似于调用 free()。 指针 ptr 必须是在动态内存空间分配成功的指针，形如如下的指针是不可以的：int *i; int a[2]；会导致运行时错误，可以简单的这样记忆：用 malloc()、calloc()、realloc() 分配成功的指针才能被 realloc() 函数接受。 成功分配内存后 ptr 将被系统回收，不可再对 ptr 指针做任何操作，包括 free()。相反的，可以对 realloc() 函数的返回值进行正常操作。 如果是扩大内存操作会把 ptr 指向的内存中的数据复制到新地址（新地址也可能会和原地址相同，但依旧不能对原指针进行任何操作）；如果是缩小内存操作，原始据会被复制并截取新长度。 返回值分配成功返回新的内存地址，可能与 ptr 相同，也可能不同。失败则返回 NULL。 12345678910111213#define SIZE 5int *p = (int *)calloc(SIZE, sizeof(int));int *rp;for (int i = 0; i &lt; SIZE; ++i){ p[i] = i;}// 扩容为之前的两倍// 注意这里使用了新指针(rp)而不是(p)，可在realloc分配失败时，防止p指向的内存泄漏rp = (int *)realloc(p, SIZE * 2);free(p);free(rp);return 0; 总结 malloc 和 colloc 都是动态分配内存，但colloc会在初始化的同时将每个字节的内存值初始化为0。 realoc 主要功能是对 malloc 和 colloc 分配的内存容量进行调整。","link":"/public-blog/posts/a1501c1d/"},{"title":"memset替换字符串的注意点","text":"字符串只读 memset 原型void * memset( void * ptr, int value, size_t num ) 其中 size_t 即是 unsigned int 参数说明ptr 为要操作的内存的指针。value 为要设置的值。你既可以向 value 传递 int 类型的值，也可以传递 char 类型的值，因为 int 和 char 可以根据 ASCII 码相互转换。num 为 ptr 的前 num 个字节。 注意：参数 value 虽声明为 int，但必须是 unsigned char，所以范围在0 到255 之间。 使用 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(){ char str[] = \"https://github.com\"; memset(str, '-', 7); puts(str); return EXIT_SUCCESS;} 输出 ——-github.com 错误使用由于字符串是只读的，不能被修改。而memset必须修改目标，所以不能直接将字符指针直接指向字符串，以下使用将在运行时报错 1234567int main(){ char *str = \"https://github.com\"; memset(str, '-', 7); puts(str); return EXIT_SUCCESS;} 报错信息： 1Bus error: 10","link":"/public-blog/posts/d8689c7b/"},{"title":"nodejs垃圾回收","text":"内存泄漏是一个老生常谈的问题，由于多数语言已经有了GC回收，且现代计算机有了更大的内存，所以不少工程师对于这方面并不太了解，今天主要谈一谈nodejs的垃圾回收机制。 如何发生内存泄漏c语言没有GC，每次分配内存需要程序员手动操作释放，这里使用一个简单c的例子来说明什么是内存泄漏。 123456//定义两个指针分别指向两块内存char * p1 = (char *)malloc(10);char * p2 = (char *)malloc(10);//将p1指向p2指向的内存p1 = p2 当p1指向p2指向的内存的时候，p1原来的那部分内存就无法操作也没有回收，这好像‘没有了’一样，这种情况就发生了内存泄漏 正常模式和精简模式hexo框架2仓2主题，采用正常模式一个仓库，一个主题；精简模式另一个仓库，另一个主题。 本博客采用的github Page部署网站。大家都知道，一个github的账户名，只能够指定一个username.github.io的网址，所以两个仓库，两个主题的话，就必须有一个挂在username.github.io之上，比如正常模式username.github.io，精简模式为username.github.io/name.io。 正常模式正常模式里面可以放各种炫酷的东西，提供丰富的页面。 精简模式只提供必要的文章，归档，分类，搜索基本的东西就够了。看个人需要，既然要简洁，就尽量的少弄一些。","link":"/public-blog/posts/e0a6bc82/"},{"title":"博客换肤的一种实现方式思路","text":"当博客内容很多的时候，比如需要加载很多资源文件，许多炫酷的东西的时候，可能相应的就是比较慢了（正可谓时间和空间不能兼得）。虽然目前也有很多方式手段可以提高访问速度，但是博客提供一个简洁模式还是很有必要的，萝卜青菜，各有所爱嘛。说不定很多网友就当纯的想看看文字，不需要那些花里胡哨的东西。这时候提供个清爽模式就相当有用了。 正常模式和精简模式hexo框架2仓2主题，采用正常模式一个仓库，一个主题；精简模式另一个仓库，另一个主题。 本博客采用的github Page部署网站。大家都知道，一个github的账户名，只能够指定一个username.github.io的网址，所以两个仓库，两个主题的话，就必须有一个挂在username.github.io之上，比如正常模式username.github.io，精简模式为username.github.io/name.io。 正常模式正常模式里面可以放各种炫酷的东西，提供丰富的页面。 精简模式只提供必要的文章，归档，分类，搜索基本的东西就够了。看个人需要，既然要简洁，就尽量的少弄一些。 配置方法关于_config.yml主配置文件的注意事项。 1234567891011+ root: /remove.io/ #精简模式- root: / #正常模式deploy: type: git+ repo: https://github.com/egsee/remove.io.git #精简模式- repo: https://github.com/egsee/egsee.github.io.git #正常模式+ theme: icarus #正常模式- theme: nextn #精简模式 对于root 根节点的说明，因为精简模式的所有资源文件都是挂在 username.github.io/remove.io/ 所以相当于根节点为/remove.io/ 总结注意事项 对于页面中对于对应模式下资源文件的引用，一定加上域名地址 ，比如原来图片访问/image/tuizi.jpg，在精简模式的时候如果继续这样用，就找不到，对应模式下的图片了，需要加上前面的username.github.io/remove.io/ 地址。 对于精简模式下，能去掉的东西就尽量去掉，尽量少加载一些，速度更快。 对于冲突页面的处理，一般对于文章或者关于页面都是通用。文章一般没啥影响，但是关于页面，可能有些也有很炫酷的模块。对于精简模式，可能不需要，此时就需要多new 一个page页面，分开配置，比如下面主题中的_config.yml配置。 12+ /remove.io/abouta/ #精简模式- /abouta/ #正常模式 本博客正常模式 精简模式 以上只是提供了一种解决方法思路，肯定还有更好的方式。","link":"/public-blog/posts/1c5449cf/"},{"title":"Git Submodule 简单使用","text":"导读 有时候我们需要在一个项目中依赖一个更新中的公共库，或者在一个大型仓库中给不同的开发人员分配各自独立的仓库，这个时候Git的子模块就很有用了。 添加一个子模块我们假设你已经创建了一个远端仓库greet.git那么可以添加这个仓库到主项目，使之成为一个子模块： 1git submodule add &lt;remote_url&gt; &lt;path&gt; 添加子模块并切换分支： 1git submodule add -b &lt;branch&gt; &lt;url&gt; &lt;path&gt; 举例： 12// 添加远程greet仓库到当前项目为greet子模块git submodule add https://github.com/&lt;username&gt;/greet.git greet 此时在主项目中会多处一个.gitmodules的文件记录子模块的信息： 123[submodule &quot;greet&quot;] path = greet url = https://github.com/&lt;username&gt;/greet.git 初始化和拉取子模块更新1git submodule update --init --recursive 或 12&lt;!-- 拉取主repo和子repo --&gt;git clone main --recursive 或 123git clone &lt;main_repository&gt;git submodule initgit submodule update 批量操作所有子模块可以使用git submodule foreach [--recursive] &lt;git command&gt;对所有子模块进行批量操作, 如 1git submodule foreach git pull","link":"/public-blog/posts/8e690a6a/"},{"title":"加密文章测试","text":"4630436162ade97ba2718b7d0c4b3b63480c11f21f943edd569d93952dd2b428ca40d00edd08503bde446612a9b43ffa557648f22736556fdb8df232a70f5b62381872db0244c43c00526e1a08cf52221edf34128af95f6689fc9f8038d2d384d80553865a152ddd5e6208a870af3b5c9bc83d20b2dbb9eed9bf4345fcbd80740d0d96973b857ce18daf962a01b68ae1d5fbd8ee95919ff5e4e59e2389903324d011f36e647c7bfde1d377a277b639b7845f1864318dedde1881f738423184c1eda461211d6767b7282687bd23a77a8725cebce8f83995baff71092164b22479 嗨，请准确无误地输入密码查看哟（密码：123456）！","link":"/public-blog/posts/7e709353/"},{"title":"NPM Workspaces简介","text":"npm在2020年10月发布的版本开始支持一个新功能：Workspaces Workspaces是什么？Workspaces即工作区，可以帮我们管理包含多个包（package）的项目，这些项目（称为monorepo）可能包含多个package.json，而Workspaces可以方便的对这类项目进行管理。 举例说明一个简单的多包依赖项目的例子如下： 123456789├── index.js├── package.json└── packages ├── packageA │ ├── index.js │ └── package.json # Dependencies: `vuepress`,`packageB` └── packageB ├── index.js └── package.json # Dependencies: `vuepress`, `packageA` 当我们在根目录运行npm install 或 yarn install的时候，npm会在根文件的node_modules下创建彼此的符号链接，以便package能够引入，如下： 1234├── node_modules # 根文件 node_modules│ ├── vuepress # 依赖的vuepress│ ├── packageA # 符号链接包A│ └── packageB # 符号链接包B 配置和使用在根项目目录下的packages.json中配置workspaces关键字： 123\"workspaces\": [ \"packages/*\", ], 子包中的package.json添加dependencies对其它包的依赖然后运行npm，则可以在子包中非常方便的使用本地依赖库了。 其它用法12345678910111213141516171819# Run \"test\" script on all packagesnpm run test --workspacesnpm run test -ws# Runs \"test\" only on packageAnpm run test --workspace packageAnpm run test -w packageB# Install `lodash` on `packageA`npm install lodash --workspace packageA# Install `tap` on `packageB` as a dev dependencynpm install tap --workspace packageB --save-dev# Install `packageA` on `packageB`npm install packageA --workspace packageB# Install `eslint` in all packagesnpm install eslint --workspaces npm 工作区 与 Yarn 工作区Yarn中也有命令来管理workspaces,例如： 1yarn workspace &lt;workspace&gt; add &lt;dependency&gt; 使用 Lerna使用 npm workspaces 和 yarn workspaces 虽然可以管理一些monorepos但对于一些更大的项目来说，它包含更多的依赖树，这时可能就要使用类似Lerna这样的管理工具了。Lerna 有很多命令来管理大型的monorepo。在VuePress项目中结合使用了这两个功能，读者可以参考其用法。 参考 NPM WorkspacesGetting Started with npm WorkspacesVuepress repository","link":"/public-blog/posts/923ed035/"}],"tags":[{"name":"加密文章","slug":"加密文章","link":"/public-blog/tags/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/"},{"name":"c/c++ 内存","slug":"c-c-内存","link":"/public-blog/tags/c-c-%E5%86%85%E5%AD%98/"},{"name":"c/c++","slug":"c-c","link":"/public-blog/tags/c-c/"},{"name":"内存","slug":"内存","link":"/public-blog/tags/%E5%86%85%E5%AD%98/"},{"name":"nodejs","slug":"nodejs","link":"/public-blog/tags/nodejs/"},{"name":"GC","slug":"GC","link":"/public-blog/tags/GC/"},{"name":"工具教程","slug":"工具教程","link":"/public-blog/tags/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"},{"name":"git","slug":"git","link":"/public-blog/tags/git/"},{"name":"github","slug":"github","link":"/public-blog/tags/github/"},{"name":"npm","slug":"npm","link":"/public-blog/tags/npm/"},{"name":"packages.json","slug":"packages-json","link":"/public-blog/tags/packages-json/"},{"name":"workspaces","slug":"workspaces","link":"/public-blog/tags/workspaces/"}],"categories":[{"name":"私密","slug":"私密","link":"/public-blog/categories/%E7%A7%81%E5%AF%86/"},{"name":"后端","slug":"后端","link":"/public-blog/categories/%E5%90%8E%E7%AB%AF/"},{"name":"工具教程","slug":"工具教程","link":"/public-blog/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"},{"name":"开发工具","slug":"开发工具","link":"/public-blog/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"前端","slug":"前端","link":"/public-blog/categories/%E5%89%8D%E7%AB%AF/"},{"name":"主题工具","slug":"工具教程/主题工具","link":"/public-blog/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/"}]}