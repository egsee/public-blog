{"pages":[{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/public-blog/media/index.html"},{"title":"","text":"","link":"/public-blog/about/index.html"},{"title":"","text":"","link":"/public-blog/message/index.html"},{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/public-blog/album/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/public-blog/music/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://egsee.github.io/public-blog/images/avatar.jpg 网站名称：EGSEE 网站地址：https://egsee.github.io/public-blog 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/public-blog/friend/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 var gitalk = new Gitalk({ clientID: 'fec450a2bb38d0063cc8', clientSecret: '24432e44cfc517df8d522a0679a34f5ada039bd9', id: '0x63cc8', repo: 'public-blog-say', owner: 'egsee', admin: \"egsee\", createIssueManually: true, distractionFreeMode: false }) gitalk.render('comment-container1')","link":"/public-blog/self-talking/index.html"}],"posts":[{"title":"博客换肤的一种实现方式思路","text":"当博客内容很多的时候，比如需要加载很多资源文件，许多炫酷的东西的时候，可能相应的就是比较慢了（正可谓时间和空间不能兼得）。虽然目前也有很多方式手段可以提高访问速度，但是博客提供一个简洁模式还是很有必要的，萝卜青菜，各有所爱嘛。说不定很多网友就当纯的想看看文字，不需要那些花里胡哨的东西。这时候提供个清爽模式就相当有用了。 正常模式和精简模式hexo框架2仓2主题，采用正常模式一个仓库，一个主题；精简模式另一个仓库，另一个主题。 本博客采用的github Page部署网站。大家都知道，一个github的账户名，只能够指定一个username.github.io的网址，所以两个仓库，两个主题的话，就必须有一个挂在username.github.io之上，比如正常模式username.github.io，精简模式为username.github.io/name.io。 正常模式正常模式里面可以放各种炫酷的东西，提供丰富的页面。 精简模式只提供必要的文章，归档，分类，搜索基本的东西就够了。看个人需要，既然要简洁，就尽量的少弄一些。 配置方法关于_config.yml主配置文件的注意事项。 1234567891011+ root: /remove.io/ #精简模式- root: / #正常模式deploy: type: git+ repo: https://github.com/egsee/remove.io.git #精简模式- repo: https://github.com/egsee/egsee.github.io.git #正常模式+ theme: icarus #正常模式- theme: nextn #精简模式 对于root 根节点的说明，因为精简模式的所有资源文件都是挂在 username.github.io/remove.io/ 所以相当于根节点为/remove.io/ 总结注意事项 对于页面中对于对应模式下资源文件的引用，一定加上域名地址 ，比如原来图片访问/image/tuizi.jpg，在精简模式的时候如果继续这样用，就找不到，对应模式下的图片了，需要加上前面的username.github.io/remove.io/ 地址。 对于精简模式下，能去掉的东西就尽量去掉，尽量少加载一些，速度更快。 对于冲突页面的处理，一般对于文章或者关于页面都是通用。文章一般没啥影响，但是关于页面，可能有些也有很炫酷的模块。对于精简模式，可能不需要，此时就需要多new 一个page页面，分开配置，比如下面主题中的_config.yml配置。 12+ /remove.io/abouta/ #精简模式- /abouta/ #正常模式 本博客正常模式 精简模式 以上只是提供了一种解决方法思路，肯定还有更好的方式。","link":"/public-blog/posts/1c5449cf/"},{"title":"Vue源码分析","text":"4630436162ade97ba2718b7d0c4b3b63480c11f21f943edd569d93952dd2b428ca40d00edd08503bde446612a9b43ffa557648f22736556fdb8df232a70f5b62381872db0244c43c00526e1a08cf52221edf34128af95f6689fc9f8038d2d384d80553865a152ddd5e6208a870af3b5c9bc83d20b2dbb9eed9bf4345fcbd80740d0d96973b857ce18daf962a01b68ae1d5fbd8ee95919ff5e4e59e2389903324d011f36e647c7bfde1d377a277b639b7845f1864318dedde1881f738423184c1eda461211d6767b7282687bd23a77a8725cebce8f83995baff71092164b22479 嗨，请准确无误地输入密码查看哟（密码：123456）！","link":"/public-blog/posts/7e709353/"},{"title":"XSS攻击介绍","text":"导读 XSS 攻击是非常常见的网页攻击了，网上有很多资料，但我始终想写一个简单的总结。 何为 XSS?XSS(Cross site script)指利用浏览器的特性，像指定网页提交特殊字符造成浏览器解析运行的一种攻击手段。XSS 有几种，个人觉得记这些意义不大，因此这里不再赘述，有兴趣的朋友可以在网上搜一下。 如何产生 XSSXSS 攻击主要来自于用户的输入，如果你的站点存在着 XSS 漏洞，那么用户就可以进行 XSS 攻击，通过运行脚本代码，用户可以获取譬如 Cookie 等较为敏感的信息。 一个 XSS 攻击的例子这里我引用LearnKu的两张图来说明 XSS 攻击事如何发生的在原文中，作者使用了 所见即所得 编辑器，指出虽然所见即所得编辑器过滤了特殊的字符，但依然可能发生 XSS 攻击，原因在于非法用户可能通过其它手段提交数据： 使用 Chrome devtools 提交数据 刷新页面发生 XSS 攻击 数据库已经有了特殊字符的数据 Chrome Devtools 示例攻击提交 1234567fetch(\"http://xss.test/demo\", { headers: { \"content-type\": \"application/x-www-form-urlencoded\", \"upgrade-insecure-requests\": \"1\" }, body: \"_token=AGL1jSjzX152b71UEAQiTzwbYdRGYnECRI17WRiG&amp;title=dangerous%20content+&amp;category_id=2&amp;body=%3Cscript%3Ealert%28%27%E5%AD%98%E5%9C%A8%20XSS%20%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%EF%BC%81%27%29%3C%2Fscript%3E\", method: \"POST\", mode: \"cors\",}); 监测XSS漏洞可以使用XSS Polylot监测XSS漏洞，文章进行了说明并有很多demo.也可以使用一些第三方检测工具Arachni、http-observatory 防范 XSS 攻击以上的例子说明，虽然各种开源的编辑器已经做了 XSS 过滤，但依然发生 XSS 攻击，这是因为后端和网页展示没有对 XSS 做过滤，因此需要前后端都对特殊字符进行过滤，以确保没有 XSS 漏洞。XSS 攻击的本质是浏览器解析了特殊字符的脚本，因此我们只需要在用户输入、页面展示、参数传输这些地方过滤这些特殊字符就可以了： 1234567字符 转义后的字符&amp; =&gt; &amp;amp;&lt; =&gt; &amp;lt;&gt; =&gt; &amp;gt;\" =&gt; &amp;quot;' =&gt; &amp;#x27;/ =&gt; &amp;#x2F; 同时JS中应注意使用innerHTML,outerHTML，如果使用他们渲染，将有可能出现XSS漏洞。 如果使用了React、Vue等框架，使用v-html,dangerouslySetInnerHTML也应小心谨慎。 使用JQuery1return $('&lt;div/&gt;').text(t).html(); prototype.js的escabeHTML()12345function escapeHTML() { return this.replace(/&amp;/g, '&amp;amp;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;');} Underscope中的escape1234567891011121314151617181920212223// List of HTML entities for escaping.var htmlEscapes = { '&amp;': '&amp;amp;', '&lt;': '&amp;lt;', '&gt;': '&amp;gt;', '\"': '&amp;quot;', \"'\": '&amp;#x27;', '/': '&amp;#x2F;'};// Regex containing the keys listed immediately above.var htmlEscaper = /[&amp;&lt;&gt;\"'\\/]/g;// Escape a string for HTML interpolation._.escape = function(string) { return ('' + string).replace(htmlEscaper, function(match) { return htmlEscapes[match]; });};// examples_.escape('Curly, Larry &amp; Moe');// =&gt; \"Curly, Larry &amp;amp; Moe\" 其它安全措施 使用Content Security PolicyCSP是一个浏览器的特性，能从根本上解决XSS漏洞问题 设置Cookie为HTTP-only这可能防止部分信息泄漏 参考 Escape HTML with JavascriptURL encoding the space character + or %20","link":"/public-blog/posts/ec76a593/"},{"title":"NPM Workspaces简介","text":"npm在2020年10月发布的版本开始支持一个新功能：Workspaces Workspaces是什么？Workspaces即工作区，可以帮我们管理包含多个包（package）的项目，这些项目（称为monorepo）可能包含多个package.json，而Workspaces可以方便的对这类项目进行管理。 举例说明一个简单的多包依赖项目的例子如下： 123456789├── index.js├── package.json└── packages ├── packageA │ ├── index.js │ └── package.json # Dependencies: `vuepress`,`packageB` └── packageB ├── index.js └── package.json # Dependencies: `vuepress`, `packageA` 当我们在根目录运行npm install 或 yarn install的时候，npm会在根文件的node_modules下创建彼此的符号链接，以便package能够引入，如下： 1234├── node_modules # 根文件 node_modules│ ├── vuepress # 依赖的vuepress│ ├── packageA # 符号链接包A│ └── packageB # 符号链接包B 配置和使用在根项目目录下的packages.json中配置workspaces关键字： 123\"workspaces\": [ \"packages/*\", ], 子包中的package.json添加dependencies对其它包的依赖然后运行npm，则可以在子包中非常方便的使用本地依赖库了。 其它用法12345678910111213141516171819# Run \"test\" script on all packagesnpm run test --workspacesnpm run test -ws# Runs \"test\" only on packageAnpm run test --workspace packageAnpm run test -w packageB# Install `lodash` on `packageA`npm install lodash --workspace packageA# Install `tap` on `packageB` as a dev dependencynpm install tap --workspace packageB --save-dev# Install `packageA` on `packageB`npm install packageA --workspace packageB# Install `eslint` in all packagesnpm install eslint --workspaces npm 工作区 与 Yarn 工作区Yarn中也有命令来管理workspaces,例如： 1yarn workspace &lt;workspace&gt; add &lt;dependency&gt; 使用 Lerna使用 npm workspaces 和 yarn workspaces 虽然可以管理一些monorepos但对于一些更大的项目来说，它包含更多的依赖树，这时可能就要使用类似Lerna这样的管理工具了。Lerna 有很多命令来管理大型的monorepo。在VuePress项目中结合使用了这两个功能，读者可以参考其用法。 参考 NPM WorkspacesGetting Started with npm WorkspacesVuepress repository","link":"/public-blog/posts/923ed035/"},{"title":"使用OpenSSL自签名证书","text":"导读 网上关于自签证书的博客资料可以说是很多了，但其中的很多写的都是含糊不清的，此篇文章将会尽量清晰的描述自签名证书和创建CA为自己的服务器颁发证书。 什么是数字证书和数字签名对于这个问题，阮一峰有一篇 文章 比较形象的解释了这个问题，此处，我们主要记录如何生成。 创建CA颁发数字证书要给我们的服务器颁发一个数字证书，我们首先需要自己创建一个证书颁发机构 CA ，通常情况下，这个CA是真实的颁发机构，我们使用Chrome访问的https网页时会出现一把锁，这些都是真实的CA颁发的，因此浏览器对此是信任的。 为CA生成一个长度为1024的私钥 1openssl genrsa -out ca.key 1024 生成CA机构自己的证书申请文件(.csr) 1openssl req -new -key ca.key -out ca.csr 使用私钥和证书申请文件为CA生成一个自己签名的证书，俗称自签名证书，这里也叫根证书 1openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt 第二个命令中，req是一个openssl的一个关于证书请求文件的子命令，可以运行openssl req --help查看帮助。最后一个命令的x509是在 ASN.1 中定义的 一种格式，X.509证书里含有公钥、身份信息(比如网络主机名，组织的名称或个体名称等)和签名信息(可以是证书签发机构CA的签名，也可以是自签名)，证书的拥有者就可以用证书及相应的私钥来创建安全的通信，对文档进行数字签名。在nginx使用https，nginx配置好后只需将ca.crt颁发给客户端电脑，客户端电脑信任后，浏览器浏览即可看到一把绿锁状态。 生成服务器私钥1openssl genrsa -out server.key 1024 生成服务器证书申请文件1openssl req -new -key server.key -out server.csr 使用CA证书签名服务器证书文件1openssl x509 -req -in server.csr -out server.crt -CA ca.crt -CAkey ca.key -CAcreateserial 自签名证书自签名证书顾名思义无需CA参与，自己给自己颁发一个证书，流程相对简单 123openssl genrsa -out server.key 1024openssl req -new -key server.key -out server.csropenssl x509 -req -in server.csr -signkey server.key -out ca.crt 也可以省略生成密钥过程，让系统自动生成 12openssl req -x509 -nodes -days 365 -newkey rsa:1024 \\-keyout /tmp/server.key -out /tmp/server.crt -nodes 选项禁止加密私钥文件。-days 指定过期时间 然后输入一些信息： 1234567Country Name (2 letter code) [AU]:State or Province Name (full name) [Some-State]:Locality Name (eg, city) []:Organization Name (eg, company) [Internet Widgits Pty Ltd]:Organizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []: 这个是你的域名或ipEmail Address []: 另外也可以只省略证书请求文件，让系统在签署过程中在内存中自动创建证书请求文件 1openssl req -new -x509 -key pri.pem -out server.crt -days 365 这样一个证书就申请好了。 其它命令查看证书申请文件一个服务器申请文件可通过openssl req -in req1.csr -noout -text来输出文件头部分，如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445Certificate Request: Data: Version: 0 (0x0) Subject: C=AU, ST=Some-State, O=Internet Widgits Pty Ltd //个人信息 Subject Public Key Info: Public Key Algorithm: rsaEncryption //使用的公钥算法 Public-Key: (2048 bit) Modulus: 00:cf:a2:a6:65:ab:e0:38:73:25:8c:d6:33:94:ba: d9:4f:6c:93:28:bc:05:81:b9:4c:07:02:93:e2:07: c3:0f:57:92:ad:16:e9:57:6f:05:93:44:66:5b:2a: 1a:54:5f:80:96:3f:b0:5a:b6:fe:70:fb:a1:4d:f5: cf:d3:fb:10:ec:8a:1c:3b:53:6c:dd:49:a8:d7:61: 52:b9:9d:06:e3:94:7a:6f:73:4d:f6:7d:7b:ad:55: bf:85:28:0d:8c:dc:50:72:5d:bb:9d:f8:ed:2a:18: 82:f2:03:b6:00:61:7f:ad:ea:36:57:00:8e:77:df: 06:00:97:d3:fe:09:35:a6:3d:0d:47:71:24:03:26: 3b:b6:37:f3:24:1d:d9:2f:c7:d8:7e:d2:db:08:b2: 49:35:6d:4c:d2:d6:57:0d:e8:6f:4c:ae:5e:50:1c: f4:bf:42:df:f1:fb:19:88:eb:0f:05:ad:69:32:da: 89:2e:ef:61:e2:95:58:11:27:ba:1c:9f:f4:7f:83: 03:de:2f:a6:73:2b:18:b5:46:82:c5:8b:85:19:c0: f4:25:d4:d8:ad:b6:81:9f:e1:b2:6d:ab:eb:ef:ba: 2d:f3:06:fa:65:54:8c:14:81:65:4b:d2:48:b4:32: fd:ae:f7:71:6d:8e:dc:9d:a6:87:47:ee:a7:11:3f: ab:a9 Exponent: 65537 (0x10001) Attributes: a0:00 Signature Algorithm: sha256WithRSAEncryption //请求文件使用的数字签名算法 95:68:5f:6a:6e:f0:b6:7c:bc:97:c7:c5:ce:76:c0:a8:3f:2a: 07:61:5f:75:ee:f0:c3:73:51:c9:b9:d7:59:68:67:06:ca:e5: a8:d3:68:19:32:27:ff:18:5f:4b:eb:02:6f:7c:f6:85:db:76: 36:56:90:3f:b6:f9:45:4a:1a:4c:74:a9:28:b1:f9:e9:f2:af: 2e:4f:d6:38:d5:72:b0:ba:11:36:92:55:9c:a3:48:61:6f:66: 73:7b:f6:35:91:cf:8a:23:aa:e1:e1:fd:ed:b1:ea:78:6c:0d: 1b:bf:6c:19:4c:a7:1c:dc:09:bb:a5:3f:2f:b2:aa:77:cb:d5: 2b:e4:57:bc:14:14:7d:ed:ec:a3:d5:b4:50:93:d3:b0:3a:07: 49:0b:fa:e7:42:b8:a6:bf:39:ae:bf:c6:66:37:f3:40:2b:59: 75:ce:c4:08:f4:b1:18:2c:48:17:a8:2c:6d:41:1e:5a:a8:86: 34:53:a7:ff:fd:e0:95:64:b7:69:9b:86:b7:66:4d:db:74:dc: c6:52:18:e9:dc:2a:b0:b1:f9:33:10:a8:d6:0d:1a:ef:0c:ac: 1b:fc:c7:61:30:ab:80:01:62:21:06:f1:7b:a7:0c:7c:bf:20: e8:d2:b6:24:a3:9a:93:ae:94:02:cf:06:23:74:1f:54:ec:16: a7:7e:44:b4 输出subject部分 1openssl req -in req.csr -subject -noout 使用-pubkey输出请求文件中的公钥 1openssl req -in req1.csr -pubkey -noout 如果是从申请证书请求时所提供的私钥中提取出公钥，那么以下输出的公钥和上面相同。 1openssl rsa -in server.key -pubout 指定证书请求文件中的签名算法如果不指定此项，默认为sha256，也支持其它很多签名算法，可以通过使用openssl dgst --help查看 12openssl req -new -key server.key -out server.csr -md5openssl req -in server.csr -noout -text | grep Algo 验证请求文件的数字签名（验证文件是否被篡改）1openssl req -verify -in server.csr //未被篡改会打印verify OK","link":"/public-blog/posts/8e14ac7c/"},{"title":"Java <T> T 和 T的区别","text":"导读最近在看Java的过程中对形如public &lt;T&gt; T get(...)的写法感到困惑，在网上很难找到合理解释。 分析1public &lt;T&gt; T readObjectData(ByteBuffer buffer, Class&lt;T&gt; type) 在上面这个方法中&lt;T&gt;代表声明了一个 通用的泛型参数TT作为一个实际的占位符，代表返回值为T类型，实际返回类型只会在使用非泛型类型参数调用时才会确定。如果这里不定义&lt;T&gt;,那么编译器将认为类型T不存在。举例来说：如果你传递Class&lt;String&gt;类型则返回的就是String类型、传递Class&lt;Double&gt;则返回Dubbo类型： 12String obj1 = clazz.readObjectData(buffer, String.class);MyClass obj2 = clazz.readObjectData(buffer, MyClass.class); 扩展大多数初学者有这样的疑惑，估计是还有以下这种类似让人迷惑的写法： 12345class MyClass&lt;T&gt; { private T myMethod(T a){ return a; }} 这样写因为在类上已经定义了&lt;T&gt;泛型参数，所以无需重复定义，如果你这样写： 12345class MyClass&lt;T&gt; { private &lt;T&gt; T myMethod(T a){ return a; }} 那么myMethod将返回的泛型类型可能不与MyClass相同，实际上像以下这样定义可能更加清晰： 12345class MyClass&lt;T1&gt; { private &lt;T2&gt; T2 myMethod(T2 a){ return a; }} 参考How to interpret “public &lt;T&gt; T” in JavaClass Literals as Runtime-Type TokensHow to interpret Java generics like &lt;T&gt; T , &lt;T,V&gt; Query&lt;T&gt; , Class&lt;T&gt;?What does “&lt;T&gt; T get()” mean?","link":"/public-blog/posts/2cc6c3c4/"},{"title":"C内存分配","text":"C 内存分配主要有 malloc、calloc、realoc 三个函数，以下简要介绍 内存分区内存里主要有几个划分，用一张表格表示| 内存分区 | 内容 | 权限 || ———- | ——————– | ——– || 栈区 | 函数中的普通变量 | 可读可写 || 堆区 | 动态申请的内存 | 可读可写 || 静态变量区 | static 修饰的变量 | 可读可写 || 数据区 | 用于初始化变量的常量 | 只读 || 代码区 | 代码指令 | 只读 | malloc、calloc、realocC\\C++允许我们使用这三个函数直接操作内存，具体就是对堆（Heap）的操作，那么这几种有哪些不同呢？ malloc 函数原型void* malloc (size_t size); 头文件头文件：#include &lt;stdlib.h&gt; 说明malloc在 Heap 区域分配一块长度为size字节的连续区域并返回该区域的地址，malloc() 函数不能为所分配的空间初始化值，需要使用 memset()，。在程序结束前，需要使用 free() 进行内存释放。 例子 1234int *p = (int *) malloc(sizeof(int));memset(p, 100, 1);printf(\"%d\\n\", *p); //输出100free(p); 注意： memset 只能给 int 类型赋值的范围为 0x00 - 0xff (即 0 - 255)，超过将按位赋值。memset 使用介绍&gt;&gt; calloc 函数原型void* calloc (size_t num, size_t size) 头文件#include &lt;stdlib.h&gt; 说明calloc和malloc类似，在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0。 使用 1char *ptr = (char *)calloc(10, 10); // 分配100个字节的内存空间 注意 由于返回的指针类型未知，所以在使用 calloc() 时通常需要进行强制类型转换，将 void 指针转换成我们希望的类型。 比较以下两种使用等效 1234char *str1 = (char *)calloc(10, 2);// malloc() 分配内存空间并用 memset() 初始化char *str2 = (char *)malloc(20);memset(str2, 0, 20); realoc 函数原型void* realloc (void* ptr, size_t size) 头文件#include &lt;stdlib.h&gt; 说明ptr 为需要重新分配的内存空间指针，size 为新的内存空间的大小，relloc为指定内存指针的动态内存（通常指 malloc 和 calloc 分配的）重新分配大小。 注意 如果 ptr 为 NULL，它的效果和 malloc() 相同，即分配 size 字节的内存空间。 如果 size 的值为 0，那么 ptr 指向的内存空间就会被释放，但是由于没有开辟新的内存空间，所以会返回空指针，类似于调用 free()。 指针 ptr 必须是在动态内存空间分配成功的指针，形如如下的指针是不可以的：int *i; int a[2]；会导致运行时错误，可以简单的这样记忆：用 malloc()、calloc()、realloc() 分配成功的指针才能被 realloc() 函数接受。 成功分配内存后 ptr 将被系统回收，不可再对 ptr 指针做任何操作，包括 free()。相反的，可以对 realloc() 函数的返回值进行正常操作。 如果是扩大内存操作会把 ptr 指向的内存中的数据复制到新地址（新地址也可能会和原地址相同，但依旧不能对原指针进行任何操作）；如果是缩小内存操作，原始据会被复制并截取新长度。 返回值分配成功返回新的内存地址，可能与 ptr 相同，也可能不同。失败则返回 NULL。 12345678910111213#define SIZE 5int *p = (int *)calloc(SIZE, sizeof(int));int *rp;for (int i = 0; i &lt; SIZE; ++i){ p[i] = i;}// 扩容为之前的两倍// 注意这里使用了新指针(rp)而不是(p)，可在realloc分配失败时，防止p指向的内存泄漏rp = (int *)realloc(p, SIZE * 2);free(p);free(rp);return 0; 总结 malloc 和 colloc 都是动态分配内存，但colloc会在初始化的同时将每个字节的内存值初始化为0。 realoc 主要功能是对 malloc 和 colloc 分配的内存容量进行调整。","link":"/public-blog/posts/a1501c1d/"},{"title":"escape、encodeURI和encodeURIComponent的区别","text":"导读 简要记录了escape,encdoeURI,encodeURIComponent的区别。 escape【已弃用】对字符串进行unicode编码,编码出来的类似%uxx格式，其中ASCII字母、数字、@*/+ 这些字符不会编码。 该函数已弃用，不建议使用 encodeURI编码URI的函数，它主要适用于将一个完整的URI进行UTF8编码:encodeURI(https://egsee.com/?id=1&amp;name=egsee#+section)。 encodeURIComponent适用于编码一个查询querystring，然后将起组装在URI上，如： 12var world = \"A string with symbols &amp; characters that have special meaning?\";var uri = 'http://example.com/foo?hello=' + encodeURIComponent(world); 总结12345678910111213141516171819202122232425262728293031323334Char encUrI encURIComp escape* * * *. . . ._ _ _ _- - - -~ ~ ~ %7E' ' ' %27! ! ! %21( ( ( %28) ) ) %29/ / %2F /+ + %2B +@ @ %40 @? ? %3F %3F= = %3D %3D: : %3A %3A# # %23 %23; ; %3B %3B, , %2C %2C$ $ %24 %24&amp; &amp; %26 %26 %20 %20 %20% %25 %25 %25^ %5E %5E %5E[ %5B %5B %5B] %5D %5D %5D{ %7B %7B %7B} %7D %7D %7D&lt; %3C %3C %3C&gt; %3E %3E %3E&quot; %22 %22 %22\\ %5C %5C %5C| %7C %7C %7C` %60 %60 %60 参考 HTML - URL EncodingShould I use encodeURI or encodeURIComponent for encoding URLs?Difference between escape(), encodeURI(), encodeURIComponent()","link":"/public-blog/posts/8312df14/"},{"title":"Java注解","text":"导读Java的注解从JDK5引入，有的注解仅仅帮助IDE给出相应提示，有的注解在runtime时会被解析成字节码，通过反射获取注解内容，有的注解专门约束其它注解类，这样的Anotation被称为元注解，本文结合自己的理解将逐一对其进行介绍。 内置注解Java的内置注解一共有7个，3个定义在java.lang中，另外4个定义在java.lang.annotation中，为了方便，我这里把java.lang中定义的注解称为内置注解，java.lang.annotation定义的注解成为元注解。 @Override检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated标记过时方法，如果使用使用，编译器会给出相应警告。 @SuppressWarnings指示编译器去忽略注解中声明的警告。比如：@SuppressWarnings(&quot;deprecation&quot;),@SuppressWarnings({&quot;deprecation&quot;, &quot;unused&quot;, &quot;unchecked&quot;}) 元注解（作用于其它注解上的注解）@Retention 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 它的值有以下几个构成： RetentionPolicy.SOURCE: Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了。 RetentionPolicy.CLASS: 编译器将Annotation存储于类对应的.class文件中。默认行为。 RetentionPolicy.RUNTIME: 编译器将Annotation存储于class文件中，并且可由JVM读入。 例子：假设有一个我们自定义了一个名叫TestAnn的注解 1234567// @Retention(RetentionPolicy.RUNTIME) #可通过反射获取注解内容// @Retention(RetentionPolicy.SOURCE) #编译器将忽视TestAnn注释public @interface TestAnn { // ...} @Target对一个自定义注解约束其使用范围，有如下值可选： ElementType.TYPE - 用在类，接口，枚举，注解的声明 ElementType.FIELD - 用在字段的和枚举常量 ElementType.METHOD - 用在方法的声明 ElementType.PARAMETER - 用在参数的声明 ElementType.CONSTRUCTOR - 在构造函数的声明 ElementType.LOCAL_VARIABLE - 用在局部变量的声明 ElementType.ANNOTATION_TYPE - 用在注释的声明 ElementType.PACKAGE - 用在包的声明例子：12345// 约束注释只能用在字段和方法上@Target(value = { ElementType.FIELD, ElementType.METHOD })public @interface TestAnn { // ...} @Documented标记这些注解是否包含在用户文档中。 @Inherited标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) @SafeVarargs (Java7支持)忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface（Java8支持）标识一个匿名函数或函数式接口。 @Repeatable（Java8支持）标识某注解可以在同一个声明上使用多次。 注解的架构Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等。 注解代码的组成Annotation.java 12345678910111213// Annotation.javapackage java.lang.annotation;public interface Annotation { boolean equals(Object obj); int hashCode(); String toString(); Class&lt;? extends Annotation&gt; annotationType();} ElementType.java 1234567891011121314151617181920// ElementType.javapackage java.lang.annotation;public enum ElementType { TYPE, /* 类、接口（包括注释类型）或枚举声明 */ FIELD, /* 字段声明（包括枚举常量） */ METHOD, /* 方法声明 */ PARAMETER, /* 参数声明 */ CONSTRUCTOR, /* 构造方法声明 */ LOCAL_VARIABLE, /* 局部变量声明 */ ANNOTATION_TYPE, /* 注释类型声明 */ PACKAGE /* 包声明 */} RetentionPolicy.java 123456789//RetentionPolicy.javapackage java.lang.annotation;public enum RetentionPolicy { SOURCE, /* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了 */ CLASS, /* 编译器将Annotation存储于类对应的.class文件中。默认行为 */ RUNTIME /* 编译器将Annotation存储于class文件中，并且可由JVM读入 */} 一个简单的例子UlRenderBorder.java 12345678910111213// UlRenderBorderpackage com.example.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(value = { ElementType.TYPE })public @interface UlBorderRender { public String border() default \"border: 1px solid #000\";} App.java 1234567891011121314151617package com.example;import com.example.annotation.UlBorderRender;public class App { public static void main(String[] args) { Class&lt;?&gt; draw = Draw.class; boolean hasUL = draw.isAnnotationPresent(UlBorderRender.class); // Method[] methods = draw.getMethods(); if(hasUL){ StringBuilder str = new StringBuilder(); UlBorderRender ulAnn = draw.getAnnotation(UlBorderRender.class); str.append(\"&lt;ul&gt;\" + ulAnn.border() + \"&lt;/ul&gt;\"); System.out.println(str); } }}","link":"/public-blog/posts/a1501c1d/"},{"title":"C/C++编译过程","text":"预处理/预编译对目标代码进行文本处理和翻译，包括： 头部文件(#include)条件编译指令(#ifdef、#endif等)、宏(#define)删除注释添加行号和文件名标识 例： 1234567891011121314#include &lt;iostream&gt; //预编译处理// #define DEBUG //预编译处理using namespace std;int main(){ string name; cout &lt;&lt; \"Enter your name:\"; cin &gt;&gt; name; cout &lt;&lt; \"Hey!\" &lt;&lt; name &lt;&lt; \"Welcome to my blog\\n\"; #ifdef DEBUG //预编译处理 cout &lt;&lt; name &lt;&lt; endl; #endif return 0;} 预处理字符都是以#开头 编译编译将原文件.cpp编译为汇编语言，这一步主要做语法分析、检查语法是否错误、词法分析产生汇编文件。 汇编讲编译完的文件翻译成机器码，每一条汇编几乎可以直接翻译成一条对应的机器指令，这一步无需语义分析和优化，生成的.o或.obj后缀的二进制对象文件。 链接链接是将生成的一个或者多个中间的文件联合生成可执行文件。链接程序的各个目标文件和库文件(.a)，成为一个能被操作系统执行的可执行文件。 g++相关命令Preprocessing - 由预处理器cpp完成，得到.i后缀的文件 1g++ -E demo.cpp -o demo.i Compilation - 由编译器ccplus完成，得到.s后缀的汇编文件 1g++ -S demo.i -o demo.s Assembly - 由汇编器as处理，得到.o的二进制目标文件 1g++ -c demo.s -o demo.o Linking - 链接器ld来完成，将二进制文件链接后得到可执行文件.out 1g++ demo.o -o demo.out","link":"/public-blog/posts/e58902ff/"},{"title":"SpringBoot报错\"Whitelabel Error Page\"","text":"今天在调试Spring的时候出现了一个”Whitelabel Error Page“页面，如图 原因Spring无法找到对应controller主应用程序(Main application class)默认情况下只会扫描到同一包下的class文件 官方文档说明。 所以解决方法有两个：1.将controller写在Main application class同包下。2.在Main application class下使用@ComponentScan注解： 12345678@ComponentScan(basePackages={\"com.egsee.demo\"}) @SpringBootApplicationpublic class Demo1Application { public static void main(String[] args) { SpringApplication.run(Demo1Application.class, args); }} 书写错误因为我是个springboot初学者，在Main Application Class下定义了一个方法，想在浏览器下访问 1234@RequestMapping(value = \"/\", produces = \"text/plain;charset=UTF-8\") public String index(){ return \"Hello Spring Boot!\"; } 但是我并没有在类中写@ResetController这种类似的注解，导致报错，加上注解后运行成功。 12345@RestController@SpringBootApplicationpublic class Demo1Application { // ...}","link":"/public-blog/posts/f9569758/"},{"title":"SpringBoot提示\"Cannot resolve symbol RestController\"","text":"最近在用maven生成springboot项目时，会报一个Cannot resolve symbol RestController的简单错误，但是对于初学者来说，Java的重量级配置错误常常会让人抓狂，这里记录如何解决这个报错。 可能原因未引入相关依赖这是最常见的原因，@ResetController定义在springboot中的spring-boot-starter-web这个artifact中,但是我的pom.xml里已经有了这个依赖却依然报错。 缓存出错由于之前idea可能发生配置错误，编辑器缓存了一些配置，导致idea一直提示此错误，我就是这种情况，折腾了很久才发现这个问题。方法是点击菜单中的&quot;File&quot; &gt;&gt; &quot;Invalidate Caches&quot; &gt;&gt; 勾选&quot;file system cache and local history&quot;确定后重启idea报错消失。","link":"/public-blog/posts/8d993f72/"},{"title":"memset替换字符串的注意点","text":"字符串只读 memset 原型void * memset( void * ptr, int value, size_t num ) 其中 size_t 即是 unsigned int 参数说明ptr 为要操作的内存的指针。value 为要设置的值。你既可以向 value 传递 int 类型的值，也可以传递 char 类型的值，因为 int 和 char 可以根据 ASCII 码相互转换。num 为 ptr 的前 num 个字节。 注意：参数 value 虽声明为 int，但必须是 unsigned char，所以范围在0 到255 之间。 使用 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(){ char str[] = \"https://github.com\"; memset(str, '-', 7); puts(str); return EXIT_SUCCESS;} 输出 ——-github.com 错误使用由于字符串是只读的，不能被修改。而memset必须修改目标，所以不能直接将字符指针直接指向字符串，以下使用将在运行时报错 1234567int main(){ char *str = \"https://github.com\"; memset(str, '-', 7); puts(str); return EXIT_SUCCESS;} 报错信息： 1Bus error: 10","link":"/public-blog/posts/d8689c7b/"},{"title":"nodejs垃圾回收","text":"内存泄漏是一个老生常谈的问题，由于多数语言已经有了GC回收，且现代计算机有了更大的内存，所以不少工程师对于这方面并不太了解，今天主要谈一谈nodejs的垃圾回收机制。 如何发生内存泄漏c语言没有GC，每次分配内存需要程序员手动操作释放，这里使用一个简单c的例子来说明什么是内存泄漏。 123456//定义两个指针分别指向两块内存char * p1 = (char *)malloc(10);char * p2 = (char *)malloc(10);//将p1指向p2指向的内存p1 = p2 当p1指向p2指向的内存的时候，p1原来的那部分内存就无法操作也没有回收，这好像‘没有了’一样，这种情况就发生了内存泄漏 正常模式和精简模式hexo框架2仓2主题，采用正常模式一个仓库，一个主题；精简模式另一个仓库，另一个主题。 本博客采用的github Page部署网站。大家都知道，一个github的账户名，只能够指定一个username.github.io的网址，所以两个仓库，两个主题的话，就必须有一个挂在username.github.io之上，比如正常模式username.github.io，精简模式为username.github.io/name.io。 正常模式正常模式里面可以放各种炫酷的东西，提供丰富的页面。 精简模式只提供必要的文章，归档，分类，搜索基本的东西就够了。看个人需要，既然要简洁，就尽量的少弄一些。","link":"/public-blog/posts/e0a6bc82/"},{"title":"四张图看懂分组加密","text":"加密一般分为对称加密和非对称加密，而对称加密又分为分组加密和序列密码。本文主要提一下分组加密 分组加密分组加密，也叫块加密(block cyphers)，一次加密明文中的一个块。是将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算（加密运算的逆运算），还原成明文组。 序列加密序列加密，也叫流加密(stream cyphers)，一次加密明文中的一个位。是指利用少量的密钥（制乱元素）通过某种复杂的运算（密码算法）产生大量的伪随机位流，用于对明文位流的加密。 分组加密常用的四种算法 ECB(Electronic Code Book)/电码本模式 ECB 是将数据按照 8 个字节一段 进行 DES 加密或解密 得到一段 8 个字节的密文或者明文, 最后一段不足 8 个字节，按照需求补足 8 个字节进行计算，之后按照顺序将计算所得的数据连在一起即可，各段数据之间互不影响。 CBC(Cipher Block Chaining)/密文分组链接方式 CBC 将 8 个字节为一组得到 D1D2..DN, D1 和初始化向量 I 异或后进行 DES 加密得到一组密文 C1，后面的分组依次使用上一次的加密结果进行 DES 加密，依此类推，最后依次链接起来得到密文。特点：CBC 不容易主动攻击,安全性好于 ECB,适合传输长度长的报文,是 SSL、IPSec 的标准。 Cipher Feedback (CFB)/密文反馈模式 CFB 的加密过程和 CBC 类似。 Output Feedback (OFB)/输出反馈模式 输出反馈模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与平文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使平文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算而在加密后进行校验也可以得出正确结果。 使用 crypto 进行对称加密 按流的方式使用 crypto 加密 12345678910111213141516scrypt(password, \"salt\", 16, (err, key) =&gt; { if (err) throw err; // 初始化iv randomFill(new Uint8Array(16), (err, iv) =&gt; { if (err) throw err; // 创建cipher const cipher = createCipheriv(algorithm, key, iv); let encrypted = \"\"; cipher.setEncoding(\"hex\"); cipher.on(\"data\", (chunk) =&gt; (encrypted += chunk)); cipher.on(\"end\", () =&gt; console.log(encrypted)); // write cipher.write(\"hello\"); cipher.end(); });}); 使用 Crypto update 加密 12345678910111213141516scrypt(\"password\", \"salt\", 16, (err, key) =&gt; { const buffer = new Uint8Array(16); // initialize iv randomFill(buffer, (err, iv) =&gt; { if (err) throw err; // cipher const cipher = createCipheriv(\"aes-128-cbc\", key, iv); let encrypted = cipher.update( fs.readFileSync(path.resolve(\".storage/temp.md\")).toString(), //需要加密的文本 \"utf8\", \"hex\" ); encrypted += cipher.final(\"hex\"); console.log(encrypted); });}); 如果想参考完整的4种加解密代码，可以从这里Clone。 参考 分组加密四种模式Recommendation for Block 2001 Edition Cipher Modes of OperationBlock Cipher Modes of Operation","link":"/public-blog/posts/79491f72/"},{"title":"C语言常用类型占用大小","text":"int现代操作系统中，int一般占用4个字节(Byte), 共32位。若不考虑正负数，当所有的位都为 1 时它的值最大，为 232-1 = 4,294,967,295 ≈ 43亿。int建议为一个机器字长，32位机器字长为4字节，64位机器字长为8字节16位环境下,int为2字节。 short短整型，占用2个字节 long长整型，16位和32位为4字节。 char占用1个字节 64位环境占用字节情况操作系统 short int longWin64 2 4 4类Unix系统 2 4 8 获取某数据类型长度：123456789101112131415#include &lt;stdio.h&gt;int main(){ short a = 10; int b = 100; int short_length = sizeof a; int int_length = sizeof(b); int long_length = sizeof(long); int char_length = sizeof(char); printf(\"short=%d, int=%d, long=%d, char=%d\\n\", short_length, int_length, long_length, char_length); return 0;} // 32 位环境以及 Win64 环境下的运行结果short=2, int=4, long=4, char=1// 64 位 Linux 和 Mac OS 下的运行结果short=2, int=4, long=8, char=1","link":"/public-blog/posts/79491f72/"},{"title":"Servlet Filter示例","text":"TODO","link":"/public-blog/posts/a35e20e9/"},{"title":"Vscode Could not create temporary directory","text":"1sudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt","link":"/public-blog/posts/e5e74770/"},{"title":"HTTP Headers之Referer","text":"导读 本文主要记录一下 Headers 中 Referer 和 Referrer-Policy 等相关字段介绍 Referer Referer 字段标记了访问来源，广泛应用于分析、日志、优化缓存等作用。Referer 字段是 Referrer 单词的错误拼写，由于历史原因沿用至今。当点击一个链接的时候，Referer包含了拥有这个链接的页面地址，而在对其它域名发起资源请求时，则包含了请求页面的地址。 构成Referer由 origin, path, querystring字段构成，fragment(e.g. “#section”) 或者 username:password 信息将不会包含在其中。 语法 Referer: &lt;url&gt; 例子“https://username:password@example.com/foo/bar/&quot;将不会包含在Referer中诸如一下的例子会包含在 Referer 中 123Referer: https://developer.mozilla.org/en-US/docs/Web/JavaScriptReferer: https://example.com/page?q=123Referer: https://example.com/ 注意：Referer 可能包含以上域名的全部或部分，这取决于 Referrer Policy Referrer-PolicyReferrer-Policy 字段主要控制将要展示哪些 Referer 信息 有一下几个选项： 12345678Referrer-Policy: no-referrerReferrer-Policy: no-referrer-when-downgradeReferrer-Policy: originReferrer-Policy: origin-when-cross-originReferrer-Policy: same-originReferrer-Policy: strict-originReferrer-Policy: strict-origin-when-cross-originReferrer-Policy: unsafe-url no-referrer省略 Referer 字段，发送请求将不会包含任何头字段 no-referrer-when-downgrade这个选项的主要意思是当从 https 访问到 http 中时不展示 referer 信息 origin只展示 Origin origin-when-cross-origin表示同源且相同级别协议（https =&gt; https, http =&gt; http）下，展示 Referer 所有信息，但在跨域和降级（https =&gt; http）访问时只展示 origin 信息。 same-origin仅在同源下展示 referer 信息 strict-origin仅在安全(https)协议下展示 referer 信息 strict-origin-when-cross-origin (默认)同源请求展示全部 referer 信息, 跨域请求且安全协议下（https =&gt; https）仅展示 origin unsafe-url任何情况下都展示完整 referer 在 HTML 里设置 referer Policy 信息也可以在 HTML 中设置 referer 策略信息，如 1&lt;meta name=\"referrer\" content=\"origin\" /&gt; 在 &lt;a&gt;, &lt;area&gt;, &lt;img&gt;, &lt;iframe&gt;, &lt;script&gt;, &lt;link&gt; 标签中可以使用referrerpolicy选项设置 referer policy 信息： 1&lt;a href=\"http://example.com\" referrerpolicy=\"origin\"&gt; 或者在一个 a, area, 或 link 元素中设置 rel 为 noreferer 注意：上面的 noreferrer 链接关系是不带破折号的。当您使用 &lt;meta&gt; 元素为整个文档指定引用策略时，应使用短划线编写：&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;。 与 CSS 集成CSS 可以从样式表中获取引用的资源。这些资源也遵循推荐人政策： 外部 CSS 样式表使用默认策略 (strict-origin-when-cross-origin)，除非它被 CSS 样式表响应中的 Referrer-Policy HTTP 标头覆盖。 对于 &lt;style&gt; 元素或样式属性，使用所有者文档的引用策略。 参考 Referrer-PolicyRefererContent Security Policy 入门教程","link":"/public-blog/posts/30eac58d/"},{"title":"HTTPS精要讲解","text":"导读 HTTPS是HTTP基于TLS/SSL安全套阶层的安全通信标准，关于它的定义、结构不在本文讨论范围之内，HTTPS的精髓在于理解它是如何工作的，在这一点上网上多数博文长篇阔论，给人一种好像看了很多，但还是在很多细节上没有彻底理解的错觉。而本文主要就是要解决这些细节问题。 场景需求阮一峰 在自己的博文 什么是数字签名 非常形象的引用了一个场景，在看本篇文章之前，建议先阅读此篇博文。 HTTPS通信过程HTTPS使用了对称加密、非对称加密、哈希算法三种算法用于保证通信数据的安全，下面简要说明为什么这样 对称加密因为 对称加密 相对于 非对称加密 加密速度更快，为了保证效率使用了对称加密。 非对称加密非对称加密较之对称加密更安全，所以HTTPS使用非对称加密来进行部分初始化加密。 哈希算法哈希主要用来做数字签名，签名能保证数据不被篡改。 由此可见，HTTPS结合了以上几种优点，在安全的同时保证了效率。 交流过程1. 客户端请求服务器（比如: https://egsee.com）。2. 服务器收到客户端请求后，会将自己由CA颁发的数字证书返回给客户端。3. 客户端收到证书后，浏览器会根据自己或系统自带的受信任的CA机构验证数字证书是否受信任，然后会使用CA对应公钥解密证书（也称根证书），从而拿到了服务器的公钥，然后用服务器的公钥加密通信明文生成数字摘要，对比服务器生成的数字签名以确定拿到的数据未被篡改。（此步骤客户端通过CA的参与安全的拿到了服务器的公钥）4. 客户端用服务器的公钥加密一个伪随机数 充当 （以后对成加密需要使用的对称加密公钥），并将加密后的公钥（也称为会话密钥）发送给服务器。5. 服务器拿到加密后的会话密钥，用自己的私钥解密后得倒会话密钥。然后使用会话密钥加密明文内容，返回给客户端。6. 客户端和服务端通过新密钥进行安全通信。 如何生成服务器证书？可参照我的另一片文章 使用OpenSSL自签名证书 总结数字签名其实就是为了保证双方通信而使用了哈希算法，以确保收到的内容不被篡改。但是中途可能有人伪造了你以为对的加密公钥，会造成和 &quot;假的对方&quot; 通信。为了解决这个问题就引入了一个权威的中间人（CA）做证明，证明后的可信公钥就叫数字证书。","link":"/public-blog/posts/1a14933b/"},{"title":"Springboot打开热部署","text":"最近在使用Springboot热启动的时候，参照了网上很多方法，但发现很多不全。 如何使用Springboot热启动 pom.xml添加依赖spring-boot-devtools 123456&lt;!-- spring-boot hot refresh --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; spring-boot-maven-plugin添加配置项fork: true 12345678&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;!-- set ture to enable hot start of devtools --&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt;&lt;/plugin&gt; 打开Preferences(Mac cmd + ，)找到Build, Exception, Deployme下的compiler,单击Compiler,在右边Build project automatically选项框内打勾。 打开auto-make,操作如下：(IDEA 2021.2版本以后)cmd + ,（Mac）打开Preferences，找到Advanced Settings,勾选右边的Allow auto-make to start...选项卡。 (IDEA 2021.2版本以前)option+cmd+shift+/(windows ctrl+alt+shift + / ) 选择 Registry 勾选compiler.automake.allow.when.app.running 5.application.properties中添加spring.devtools.restart.enabled=true","link":"/public-blog/posts/aa953346/"},{"title":"Git Submodule 简单使用","text":"导读 URL由多部分构成，不同的语言解析URL函数得到的名称并不完全相同，恰巧在网上看到一篇不错关于URL组成的图形化描述，在此记录。 URL组成1\"https://bob:bobby@www.lunatech.com:8080/file;p=1?q=2#third\" 一个这样的URL，可以提取到以下信息： 123456789101112131415161718192021+-------------------+---------------------+| Part | Data |+-------------------+---------------------+| Scheme | https || User | bob || Password | bobby || Host | www.lunatech.com || Port | 8080 || Path | /file;p=1 || Path parameter | p=1 || Query | q=2 || Fragment | third |+-------------------+---------------------+https://bob:bobby@www.lunatech.com:8080/file;p=1?q=2#third\\___/ \\_/ \\___/ \\______________/ \\__/\\_______/ \\_/ \\___/ | | | | | | \\_/ | |Scheme User Password Host Port Path | | Fragment \\_____________________________/ | Query | Path parameter Authority 使用nodejs URL函数打印的URL信息： 1234567891011121314151617&gt; const url = \"https://bob:bobby@www.lunatech.com:8080/file;p=1?q=2#third\"&gt; new URL(url)URL { href: 'https://bob:bobby@www.lunatech.com:8080/file;p=1?q=2#third', origin: 'https://www.lunatech.com:8080', protocol: 'https:', username: 'bob', password: 'bobby', host: 'www.lunatech.com:8080', hostname: 'www.lunatech.com', port: '8080', pathname: '/file;p=1', search: '?q=2', searchParams: URLSearchParams { 'q' =&gt; '2' }, hash: '#third'} 参考 Url encoding the space character or %20","link":"/public-blog/posts/8e690a6a/"},{"title":"Git子模块简单使用","text":"导读 有时候我们需要在一个项目中依赖一个更新中的公共库，或者在一个大型仓库中给不同的开发人员分配各自独立的仓库，这个时候Git的子模块就很有用了。 添加一个子模块我们假设你已经创建了一个远端仓库greet.git那么可以添加这个仓库到主项目，使之成为一个子模块： 1git submodule add &lt;remote_url&gt; &lt;path&gt; 添加子模块并切换分支： 1git submodule add -b &lt;branch&gt; &lt;url&gt; &lt;path&gt; 举例： 12// 添加远程greet仓库到当前项目为greet子模块git submodule add https://github.com/&lt;username&gt;/greet.git greet 此时在主项目中会多处一个.gitmodules的文件记录子模块的信息： 123[submodule &quot;greet&quot;] path = greet url = https://github.com/&lt;username&gt;/greet.git 初始化和拉取子模块更新1git submodule update --init --recursive 或 12&lt;!-- 拉取主repo和子repo --&gt;git clone main --recursive 或 123git clone &lt;main_repository&gt;git submodule initgit submodule update 批量操作所有子模块可以使用git submodule foreach [--recursive] &lt;git command&gt;对所有子模块进行批量操作, 如 1git submodule foreach git pull","link":"/public-blog/posts/8e690a6a/"},{"title":"Chrome资源覆盖率","text":"导读 我们经常在Chrome里面调试网页，以下演示了如何查看脚本资源代码的使用率 可以看到演示中的Unused Bytes是很高的。","link":"/public-blog/posts/deac4cd7/"},{"title":"Go数组和切片","text":"数组定义Go 数组是具有相同 唯一类型 的一组已编号且长度固定的数据项序列 声明方式123arr := [3]int{1,2,3}//orarr := [...]int{1,2,3,4,5} 数组声明后值分配为零，在内存中是连续固定不可变的区域。数组是值类型，意味着传递数组会重新复制一份传递，这和 C 或 Java 有所不同 示例12345678910111213import \"fmt\"func main() { var arr1 [5]int for i:=0; i &lt; len(arr1); i++ { arr1[i] = i * 2 } for i:=0; i &lt; len(arr1); i++ { fmt.Printf(\"Array at index %d is %d\\n\", i, arr1[i]) }} 切片定义切片（slice）是对数组一个连续片段的引用，其底层是数组，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型），可以将其理解为一个可变数组。 声明和定义1234567891011// 长度3 容量5的切片s1 := make([]int, 3, 5)//s2 := []int{1,2,3}s3 := s1[1:3]//定义数组arr := [3]{1,2,3}s := a[:] //转换为slices = append(s, 4, 5) // s = {1,2,3,4,5}fmt.Println(len(s), cap(s)) 内存示意 例子12345678910111213141516171819202122232425262728293031import \"fmt\"func main() { var arr1 [6]int var slice1 []int = arr1[2:5] // item at index 5 not included! // load the array with integers: 0,1,2,3,4,5 for i := 0; i &lt; len(arr1); i++ { arr1[i] = i } // print the slice for i := 0; i &lt; len(slice1); i++ { fmt.Printf(\"Slice at %d is %d\\n\", i, slice1[i]) } fmt.Printf(\"The length of arr1 is %d\\n\", len(arr1)) fmt.Printf(\"The length of slice1 is %d\\n\", len(slice1)) fmt.Printf(\"The capacity of slice1 is %d\\n\", cap(slice1)) // grow the slice slice1 = slice1[0:4] for i := 0; i &lt; len(slice1); i++ { fmt.Printf(\"Slice at %d is %d\\n\", i, slice1[i]) } fmt.Printf(\"The length of slice1 is %d\\n\", len(slice1)) fmt.Printf(\"The capacity of slice1 is %d\\n\", cap(slice1)) // grow the slice beyond capacity //slice1 = slice1[0:7 ] // panic: runtime error: slice bound out of range} slicing 细节s := make([]int, 5)，s 底层即为上图的数据结构。ptr 是一个指针，指向底层对应的数组。len 是切片的长度 5，cap 是底层数组的容量 5。 当我们执行下面语句时 ： 1s2 := s[1:3] 做 slicing 的时候，go 会新建一个 slice 值 s2，而底层的数据是不动的。s2 如上图深蓝色，通过更改指针、长度和容量来进行 slicing。这也就是为什么 slicing 的性能非常高的原因。 一个 slice 不能越过 cap 进行操作，这个我们从底层很容易理解，因为就相当于越过底层数组的上界进行非法访问了。 切片扩容使用内部函数 append 来往切片 slice 后动态追加元素，当 cap 不够时，如果 reslice 后可以放下，那么它会 reslice。例如上面的 s2，底层的数组足以再追加 2 个元素。如果不行，那么它会 new 一个新的底层数组，大小为之前 cap 的两倍，并将之前的元素复制进去: 1234567891011s := make([]int, 5)s = append(s, 6, 7)fmt.Println(len(s), cap(s)) // 输出7 10s = append(s, 8, 9, 10, 11)fmt.Println(len(s), cap(s))//输出11 20如果要追加一个slice到另一个slice的话，这样：s5 := make([]int, 5)s6 := []int{11, 22, 33, 44, 55, 66}s := append(s5, s6...)fmt.Println(s, len(s), cap(s))//输出[0 0 0 0 0 11 22 33 44 55 66] 11 12 使用注意在这样的场景下注意：如果我们只用到一个 slice 的一小部分，那么底层的整个数组也将继续保存在内存当中。当这个底层数组很大，或者这样的场景很多时，可能会造成内存急剧增加，造成崩溃。 所以在这样的场景下，我们可以将需要的分片复制到一个新的 slice 中去，减少内存的占用。例如一个很大的切片 data 里，我们需要的数据是 data[m:n]，那么我们创建一个新的 slice 变量 r，将数据复制到 r 中返回。 1234mydata := data[m:n]r := make([]int, len(mydata))copy(r, mydata)return r 举例区别切片： 12345678910111213141516numbers := []int{1, 2, 3, 4, 5, 6}for i, e := range numbers { if i == len(numbers)-1 { numbers[0] += e } else { numbers[i+1] += e }}fmt.Println(numbers) // [22 3 6 10 15 21] 数组： 1234567891011121314151617numbers := [...]int{1, 2, 3, 4, 5, 6}for i, e := range numbers { if i == len(numbers)-1 { numbers[0] += e } else { numbers[i+1] += e }}fmt.Println(numbers) // [7 3 5 7 9 11] 遍历时数组类型是值类型，而切片是指针类型，每次传递的是指针，所以每次累加，都是改变后的值来累加。 使用 Benchmark 展示 slice 内存使用12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"math/rand\" \"testing\" \"time\")func generateWithCap(n int) []int { rand.Seed(time.Now().UnixNano()) nums := make([]int, 0, n) for i := 0; i &lt; n; i++ { nums = append(nums, rand.Int()) } return nums}func generate(n int) []int { rand.Seed(time.Now().UnixNano()) nums := make([]int, 0) for i := 0; i &lt; n; i++ { nums = append(nums, rand.Int()) } return nums}func BenchmarkGenerateWithCap(b *testing.B) { for n := 0; n &lt; b.N; n++ { generateWithCap(1000000) }}func BenchmarkGenerate(b *testing.B) { for n := 0; n &lt; b.N; n++ { generate(1000000) }} 运行结果： 12345678go test -bench='Generate' .goos: darwingoarch: amd64pkg: exampleBenchmarkGenerateWithCap-8 44 24294582 ns/opBenchmarkGenerate-8 34 30342763 ns/opPASSok example 2.171s 可以看到生成 100w 个数字的随机序列，GenerateWithCap 的耗时比 Generate 少 20%。使用 -benchmem 参数看到内存分配的情况： 1234567goos: darwingoarch: amd64pkg: exampleBenchmarkGenerateWithCap-8 43 24335658 ns/op 8003641 B/op 1 allocs/opBenchmarkGenerate-8 33 30403687 ns/op 45188395 B/op 40 allocs/opPASSok example 2.121s Generate 分配的内存是 GenerateWithCap 的 6 倍，设置了切片容量，内存只分配一次，而不设置切片容量，内存分配了 40 次。 参考：Go语言高性能编程数组和切片搞懂golang中的数组和切片slice","link":"/public-blog/posts/94f857ff/"},{"title":"Js EventLoop","text":"The Event LoopJavascript has a runtime model based on Event Loop, which is responsible for excuting the code, collecting and processing events, and excuting queued sub-tasks. The model is quite different from models in other languages like C and Java.","link":"/public-blog/posts/b02d5628/"},{"title":"Docker Entrypoint","text":"redis entrypoint example123456789#!/bin/sh...# allow the container to be started with `--user`if [ \"$1\" = 'redis-server' -a \"$(id -u)\" = '0' ]; then find . \\! -user redis -exec chown redis '{}' + exec gosu redis \"$0\" \"$@\"fiexec \"$@\" 该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如： 12$ docker run -it redis iduid=0(root) gid=0(root) groups=0(root) postgres1234567891011121314#!/bin/bashset -eif [ \"$1\" = 'postgres' ]; then chown -R postgres \"$PGDATA\" if [ -z \"$(ls -A \"$PGDATA\")\" ]; then gosu postgres initdb fi exec gosu postgres \"$@\"fiexec \"$@ 注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。 该辅助脚本被拷贝到容器，并在容器启动时通过 ENTRYPOINT 执行： 123COPY ./docker-entrypoint.sh /ENTRYPOINT [\"/docker-entrypoint.sh\"]","link":"/public-blog/posts/7fe8ab1e/"}],"tags":[{"name":"工具教程","slug":"工具教程","link":"/public-blog/tags/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"},{"name":"加密文章","slug":"加密文章","link":"/public-blog/tags/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/"},{"name":"web安全","slug":"web安全","link":"/public-blog/tags/web%E5%AE%89%E5%85%A8/"},{"name":"网络安全","slug":"网络安全","link":"/public-blog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"npm","slug":"npm","link":"/public-blog/tags/npm/"},{"name":"workspaces","slug":"workspaces","link":"/public-blog/tags/workspaces/"},{"name":"密码学","slug":"密码学","link":"/public-blog/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"java","slug":"java","link":"/public-blog/tags/java/"},{"name":"泛型","slug":"泛型","link":"/public-blog/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"c/c++ 内存","slug":"c-c-内存","link":"/public-blog/tags/c-c-%E5%86%85%E5%AD%98/"},{"name":"前端基础","slug":"前端基础","link":"/public-blog/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"java注解,java annotation","slug":"java注解-java-annotation","link":"/public-blog/tags/java%E6%B3%A8%E8%A7%A3-java-annotation/"},{"name":"c/c++","slug":"c-c","link":"/public-blog/tags/c-c/"},{"name":"springboot","slug":"springboot","link":"/public-blog/tags/springboot/"},{"name":"debug","slug":"debug","link":"/public-blog/tags/debug/"},{"name":"内存","slug":"内存","link":"/public-blog/tags/%E5%86%85%E5%AD%98/"},{"name":"nodejs","slug":"nodejs","link":"/public-blog/tags/nodejs/"},{"name":"GC","slug":"GC","link":"/public-blog/tags/GC/"},{"name":"vscode","slug":"vscode","link":"/public-blog/tags/vscode/"},{"name":"headers","slug":"headers","link":"/public-blog/tags/headers/"},{"name":"https","slug":"https","link":"/public-blog/tags/https/"},{"name":"tls/ssl","slug":"tls-ssl","link":"/public-blog/tags/tls-ssl/"},{"name":"git","slug":"git","link":"/public-blog/tags/git/"},{"name":"github","slug":"github","link":"/public-blog/tags/github/"},{"name":"调试工具","slug":"调试工具","link":"/public-blog/tags/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"},{"name":"go","slug":"go","link":"/public-blog/tags/go/"},{"name":"dockerfile","slug":"dockerfile","link":"/public-blog/tags/dockerfile/"},{"name":"docker","slug":"docker","link":"/public-blog/tags/docker/"}],"categories":[{"name":"工具教程","slug":"工具教程","link":"/public-blog/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"},{"name":"私密","slug":"私密","link":"/public-blog/categories/%E7%A7%81%E5%AF%86/"},{"name":"主题工具","slug":"工具教程/主题工具","link":"/public-blog/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/"},{"name":"web安全","slug":"web安全","link":"/public-blog/categories/web%E5%AE%89%E5%85%A8/"},{"name":"前端基础","slug":"前端基础","link":"/public-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"后端","slug":"后端","link":"/public-blog/categories/%E5%90%8E%E7%AB%AF/"},{"name":"java","slug":"后端/java","link":"/public-blog/categories/%E5%90%8E%E7%AB%AF/java/"},{"name":"nodejs","slug":"nodejs","link":"/public-blog/categories/nodejs/"},{"name":"密码学","slug":"密码学","link":"/public-blog/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"片段","slug":"片段","link":"/public-blog/categories/%E7%89%87%E6%AE%B5/"},{"name":"c/c++","slug":"后端/c-c","link":"/public-blog/categories/%E5%90%8E%E7%AB%AF/c-c/"},{"name":"开发工具","slug":"开发工具","link":"/public-blog/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"调试工具","slug":"调试工具","link":"/public-blog/categories/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"},{"name":"go","slug":"后端/go","link":"/public-blog/categories/%E5%90%8E%E7%AB%AF/go/"}]}